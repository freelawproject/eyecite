<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>eyecite.models API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>eyecite.models</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
import re
from collections import UserString
from dataclasses import asdict, dataclass, field
from datetime import datetime
from typing import (
    Any,
    Callable,
    Dict,
    Hashable,
    Iterable,
    List,
    Optional,
    Sequence,
    Tuple,
    Union,
    cast,
)

from eyecite import clean_text
from eyecite.annotate import SpanUpdater
from eyecite.utils import REPORTERS_THAT_NEED_PAGE_CORRECTION, hash_sha256

logger = logging.getLogger(__name__)

ResourceType = Hashable


@dataclass(eq=True, frozen=True)
class Reporter:
    &#34;&#34;&#34;Class for top-level reporters in `reporters_db`, like &#34;S.W.&#34; &#34;&#34;&#34;

    short_name: str
    name: str
    cite_type: str
    source: str  # one of &#34;reporters&#34;, &#34;laws&#34;, &#34;journals&#34;
    is_scotus: bool = False

    def __post_init__(self):
        if (
            self.cite_type == &#34;federal&#34; and &#34;supreme&#34; in self.name.lower()
        ) or &#34;scotus&#34; in self.cite_type.lower():
            # use setattr because this class is frozen
            object.__setattr__(self, &#34;is_scotus&#34;, True)


@dataclass(eq=True, frozen=True)
class Edition:
    &#34;&#34;&#34;Class for individual editions in `reporters_db`,
    like &#34;S.W.&#34; and &#34;S.W.2d&#34;.&#34;&#34;&#34;

    reporter: Reporter
    short_name: str
    start: Optional[datetime]
    end: Optional[datetime]

    def includes_year(
        self,
        year: int,
    ) -&gt; bool:
        &#34;&#34;&#34;Return True if edition contains cases for the given year.&#34;&#34;&#34;
        return (
            year &lt;= datetime.now().year
            and (self.start is None or self.start.year &lt;= year)
            and (self.end is None or self.end.year &gt;= year)
        )


@dataclass(eq=False, unsafe_hash=False)
class CitationBase:
    &#34;&#34;&#34;Base class for objects returned by `eyecite.find.get_citations`. We
    define several subclasses of this class below, representing the various
    types of citations that might exist.&#34;&#34;&#34;

    token: &#34;Token&#34;  # token this citation came from
    index: int  # index of _token in the token list
    # span() overrides
    span_start: Optional[int] = None
    span_end: Optional[int] = None
    full_span_start: Optional[int] = None
    full_span_end: Optional[int] = None
    groups: dict = field(default_factory=dict)
    metadata: Any = None
    document: Optional[&#34;Document&#34;] = None

    def __post_init__(self):
        &#34;&#34;&#34;Set up groups and metadata.&#34;&#34;&#34;
        # Allow groups to be used in comparisons:
        self.groups = self.token.groups
        # Make metadata a self.Metadata object:
        self.metadata = (
            self.Metadata(**self.metadata)
            if isinstance(self.metadata, dict)
            else self.Metadata()
        )
        # Set known missing page numbers to None
        if re.search(&#34;^_+$&#34;, self.groups.get(&#34;page&#34;, &#34;&#34;) or &#34;&#34;):
            self.groups[&#34;page&#34;] = None

    def __repr__(self):
        &#34;&#34;&#34;Simplified repr() to be more readable than full dataclass repr().
        Just shows &#39;FullCaseCitation(&#34;matched text&#34;, groups=...)&#39;.&#34;&#34;&#34;
        return (
            f&#34;{self.__class__.__name__}(&#34;
            + f&#34;{repr(self.matched_text())}&#34;
            + (f&#34;, groups={repr(self.groups)}&#34; if self.groups else &#34;&#34;)
            + f&#34;, metadata={repr(self.metadata)}&#34;
            + &#34;)&#34;
        )

    def __hash__(self) -&gt; int:
        &#34;&#34;&#34;In general, citations are considered equivalent if they have the
        same group values (i.e., the same regex group content that is extracted
        from the matched text). Subclasses may override this method in order to
        specify equivalence behavior that is more appropriate for certain
        kinds of citations (e.g., see CaseCitation override).

        self.groups typically contains different keys for different objects:

        FullLawCitation (non-exhaustive and non-guaranteed):
        - chapter
        - reporter
        - law_section
        - issue
        - page
        - docket_number
        - pamphlet
        - title

        FullJournalCitation (non-exhaustive and non-guaranteed):
        - volume
        - reporter
        - page

        FullCaseCitation (see CaseCitation.__hash__() notes)
        &#34;&#34;&#34;
        return hash(
            hash_sha256(
                {**dict(self.groups.items()), **{&#34;class&#34;: type(self).__name__}}
            )
        )

    def __eq__(self, other):
        &#34;&#34;&#34;This method is inherited by all subclasses and should not be
        overridden. It implements object equality in exactly the same way as
        defined in an object&#39;s __hash__() function, which should be overridden
        instead if desired.
        &#34;&#34;&#34;
        return self.__hash__() == other.__hash__()

    @dataclass(eq=True, unsafe_hash=True)
    class Metadata:
        &#34;&#34;&#34;Define fields on self.metadata.&#34;&#34;&#34;

        parenthetical: Optional[str] = None
        pin_cite: Optional[str] = None
        pin_cite_span_start: Optional[int] = None
        pin_cite_span_end: Optional[int] = None

    def corrected_citation(self):
        &#34;&#34;&#34;Return citation with any variations normalized.&#34;&#34;&#34;
        return self.matched_text()

    def corrected_citation_full(self):
        &#34;&#34;&#34;Return citation with any variations normalized, including extracted
        metadata if any.&#34;&#34;&#34;
        return self.matched_text()

    def dump(self) -&gt; dict:
        &#34;&#34;&#34;Return citation data for printing by dump_citations.&#34;&#34;&#34;
        return {
            &#34;groups&#34;: self.groups,
            &#34;metadata&#34;: {
                k: v
                for k, v in self.metadata.__dict__.items()
                if v is not None
            },
        }

    def matched_text(self):
        &#34;&#34;&#34;Text that identified this citation, such as &#39;1 U.S. 1&#39; or &#39;Id.&#39;&#34;&#34;&#34;
        return str(self.token)

    def span(self):
        &#34;&#34;&#34;Start and stop offsets in source text for matched_text().&#34;&#34;&#34;
        return (
            (
                self.span_start
                if self.span_start is not None
                else self.token.start
            ),
            self.span_end if self.span_end is not None else self.token.end,
        )

    def span_with_pincite(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Start and stop offsets in source text for pin cites.&#34;&#34;&#34;
        start = min(
            list(
                filter(
                    lambda v: v is not None,
                    [
                        self.metadata.pin_cite_span_start,
                        self.span_start,
                        self.token.start,
                    ],
                )
            ),
            default=self.token.start,
        )

        end = max(
            list(
                filter(
                    lambda v: v is not None,
                    [
                        self.metadata.pin_cite_span_end,
                        self.token.end,
                        self.span_end,
                    ],
                )
            ),
            default=self.token.end,
        )

        return (start, end)

    def full_span(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Span indices that fully cover the citation

        Start and stop offsets in source text for full citation text (including
        plaintiff, defendant, post citation, ...)

        Relevant for FullCaseCitation, FullJournalCitation and FullLawCitation.

        :returns: Tuple of start and end indicies
        &#34;&#34;&#34;
        start = self.full_span_start
        if start is None:
            start = self.span()[0]

        end = self.full_span_end
        if end is None:
            end = self.span()[1]

        return start, end


@dataclass(eq=False, unsafe_hash=False, repr=False)
class ResourceCitation(CitationBase):
    &#34;&#34;&#34;Base class for a case, law, or journal citation. Could be short or
    long.&#34;&#34;&#34;

    # Editions that might match this reporter string
    exact_editions: Sequence[Edition] = field(default_factory=tuple)
    variation_editions: Sequence[Edition] = field(default_factory=tuple)
    all_editions: Sequence[Edition] = field(default_factory=tuple)
    edition_guess: Optional[Edition] = None

    # year extracted from metadata[&#34;year&#34;] and converted to int,
    # if in a valid range
    year: Optional[int] = None

    def __post_init__(self):
        &#34;&#34;&#34;Make iterables into tuples to make sure we&#39;re hashable.&#34;&#34;&#34;
        self.exact_editions = tuple(self.exact_editions)
        self.variation_editions = tuple(self.variation_editions)
        self.all_editions = tuple(self.exact_editions) + tuple(
            self.variation_editions
        )
        super().__post_init__()

    def __hash__(self) -&gt; int:
        &#34;&#34;&#34;ResourceCitation objects are hashed in the same way as their
        parent class (CitationBase) objects, except that we also take into
        consideration the all_editions field.
        &#34;&#34;&#34;
        return hash(
            hash_sha256(
                {
                    **dict(self.groups.items()),
                    **{
                        &#34;all_editions&#34;: sorted(
                            [asdict(e) for e in self.all_editions],
                            key=lambda d: d[&#34;short_name&#34;],  # type: ignore
                        ),
                        &#34;class&#34;: type(self).__name__,
                    },
                }
            )
        )

    @dataclass(eq=True, unsafe_hash=True)
    class Metadata(CitationBase.Metadata):
        &#34;&#34;&#34;Define fields on self.metadata.&#34;&#34;&#34;

        year: Optional[str] = None

    def add_metadata(self, document: &#34;Document&#34;):
        &#34;&#34;&#34;Extract metadata from text before and after citation.&#34;&#34;&#34;
        self.guess_edition()

    def dump(self) -&gt; dict:
        &#34;&#34;&#34;Return citation data for printing by dump_citations.&#34;&#34;&#34;
        return {
            **super().dump(),
            &#34;year&#34;: self.year,
        }

    def corrected_reporter(self):
        &#34;&#34;&#34;Get official reporter string from edition_guess, if possible.&#34;&#34;&#34;
        return (
            self.edition_guess.short_name
            if self.edition_guess
            else self.groups[&#34;reporter&#34;]
        )

    def corrected_citation(self):
        &#34;&#34;&#34;Return citation with corrected reporter and standardized page&#34;&#34;&#34;
        corrected = self.matched_text()
        if self.edition_guess:
            corrected = corrected.replace(
                self.groups.get(&#34;reporter&#34;), self.edition_guess.short_name
            )

        corrected_page = self.corrected_page()
        if corrected_page and corrected_page != self.groups[&#34;page&#34;]:
            corrected = corrected.replace(self.groups[&#34;page&#34;], corrected_page)

        return corrected

    def corrected_page(self):
        &#34;&#34;&#34;Can we standardize a page value?&#34;&#34;&#34;
        page = self.groups.get(&#34;page&#34;)
        if page is None:
            return

        standard_reporter = &#34;&#34;
        if reporter := self.groups.get(&#34;reporter&#34;):
            if self.edition_guess:
                standard_reporter = self.edition_guess.short_name
            if {
                reporter,
                standard_reporter,
            } &amp; REPORTERS_THAT_NEED_PAGE_CORRECTION:
                return page.replace(&#34;[U]&#34;, &#34;(U)&#34;).replace(&#34;[A]&#34;, &#34;(A)&#34;)

        return page

    def guess_edition(self):
        &#34;&#34;&#34;Set edition_guess.&#34;&#34;&#34;
        # Use exact matches if possible, otherwise try variations
        editions = self.exact_editions or self.variation_editions
        if not editions:
            return

        # Attempt resolution by date
        if len(editions) &gt; 1 and self.year:
            editions = [e for e in editions if e.includes_year(self.year)]

        if len(editions) == 1:
            self.edition_guess = editions[0]


@dataclass(eq=False, unsafe_hash=False, repr=False)
class FullCitation(ResourceCitation):
    &#34;&#34;&#34;Abstract base class indicating that a citation fully identifies a
    resource.&#34;&#34;&#34;


@dataclass(eq=False, unsafe_hash=False, repr=False)
class FullLawCitation(FullCitation):
    &#34;&#34;&#34;Citation to a source from `reporters_db/laws.json`.&#34;&#34;&#34;

    @dataclass(eq=True, unsafe_hash=True)
    class Metadata(FullCitation.Metadata):
        &#34;&#34;&#34;Define fields on self.metadata.&#34;&#34;&#34;

        publisher: Optional[str] = None
        day: Optional[str] = None
        month: Optional[str] = None

    def add_metadata(self, document: &#34;Document&#34;):
        &#34;&#34;&#34;Extract metadata from text before and after citation.&#34;&#34;&#34;
        # pylint: disable=import-outside-toplevel
        from eyecite.helpers import add_law_metadata

        add_law_metadata(self, document.words)
        super().add_metadata(document)

    def corrected_citation_full(self):
        &#34;&#34;&#34;Return citation with any variations normalized, including extracted
        metadata if any.&#34;&#34;&#34;
        parts = [self.corrected_citation()]
        m = self.metadata
        if m.pin_cite:
            parts.append(f&#34;{m.pin_cite}&#34;)
        publisher_date = &#34; &#34;.join(
            i for i in (m.publisher, m.month, m.day, m.year) if i
        )
        if publisher_date:
            parts.append(f&#34; ({publisher_date})&#34;)
        if m.parenthetical:
            parts.append(f&#34; ({m.parenthetical})&#34;)
        return &#34;&#34;.join(parts)


@dataclass(eq=False, unsafe_hash=False, repr=False)
class FullJournalCitation(FullCitation):
    &#34;&#34;&#34;Citation to a source from `reporters_db/journals.json`.&#34;&#34;&#34;

    def add_metadata(self, document: &#34;Document&#34;):
        &#34;&#34;&#34;Extract metadata from text before and after citation.&#34;&#34;&#34;
        # pylint: disable=import-outside-toplevel
        from eyecite.helpers import add_journal_metadata

        add_journal_metadata(self, document.words)
        super().add_metadata(document)

    def corrected_citation_full(self):
        &#34;&#34;&#34;Return citation with any variations normalized, including extracted
        metadata if any.&#34;&#34;&#34;
        parts = [self.corrected_citation()]
        m = self.metadata
        if m.pin_cite:
            parts.append(f&#34;, {m.pin_cite}&#34;)
        if m.year:
            parts.append(f&#34; ({m.year})&#34;)
        if m.parenthetical:
            parts.append(f&#34; ({m.parenthetical})&#34;)
        return &#34;&#34;.join(parts)


@dataclass(eq=False, unsafe_hash=False, repr=False)
class CaseCitation(ResourceCitation):
    &#34;&#34;&#34;Convenience class which represents a single citation found in a
    document.
    &#34;&#34;&#34;

    def __hash__(self) -&gt; int:
        &#34;&#34;&#34;CaseCitation objects that have the same volume, reporter, and page
        are considered equivalent, unless the citation is missing a page, in
        which case the object&#39;s hash will be unique for safety.

        self.groups for CaseCitation objects usually contains these keys:
        - page (guaranteed here: https://github.com/freelawproject/reporters-db/blob/main/tests.py#L129)  # noqa: E501
        - reporter (guaranteed here: https://github.com/freelawproject/reporters-db/blob/main/tests.py#L129)  # noqa: E501
        - volume (almost always present, but some tax court citations don&#39;t have volumes)  # noqa: E501
        - reporter_nominative (sometimes)
        - volumes_nominative (sometimes)
        &#34;&#34;&#34;
        if self.groups[&#34;page&#34;] is None:
            return id(self)
        else:
            return hash(
                hash_sha256(
                    {
                        **{
                            k: self.groups[k]
                            for k in [&#34;volume&#34;, &#34;page&#34;]
                            if k in self.groups
                        },
                        **{
                            &#34;reporter&#34;: self.corrected_reporter(),
                            &#34;class&#34;: type(self).__name__,
                        },
                    }
                )
            )

    @dataclass(eq=True, unsafe_hash=True)
    class Metadata(FullCitation.Metadata):
        &#34;&#34;&#34;Define fields on self.metadata.&#34;&#34;&#34;

        # court is included for ShortCaseCitation as well. It won&#39;t appear in
        # the cite itself but can also be guessed from the reporter
        court: Optional[str] = None

    def guess_court(self):
        &#34;&#34;&#34;Set court based on reporter.&#34;&#34;&#34;
        if not self.metadata.court and any(
            e.reporter.is_scotus for e in self.all_editions
        ):
            self.metadata.court = &#34;scotus&#34;


@dataclass(eq=False, unsafe_hash=False, repr=False)
class FullCaseCitation(CaseCitation, FullCitation):
    &#34;&#34;&#34;Convenience class which represents a standard, fully named citation,
    i.e., the kind of citation that marks the first time a document is cited.

    Example:
    ```
    Adarand Constructors, Inc. v. Peña, 515 U.S. 200, 240
    Peña at 222, 515 U.S. 200
    ```
    &#34;&#34;&#34;

    def is_parallel_citation(self, preceding: CaseCitation):
        &#34;&#34;&#34;Check if preceding citation is parallel

        Args:
            preceding (): The previous citation found

        Returns: None
        &#34;&#34;&#34;
        if self.full_span_start == preceding.full_span_start:
            # if parallel get plaintiff/defendant data from
            # the earlier citation, since it won&#39;t be on the
            # parallel one.
            self.metadata.defendant = preceding.metadata.defendant
            self.metadata.plaintiff = preceding.metadata.plaintiff
            # California style may have a year prior to citation; merge as well
            self.metadata.year = preceding.metadata.year
            self.year = preceding.year

    @dataclass(eq=True, unsafe_hash=True)
    class Metadata(CaseCitation.Metadata):
        &#34;&#34;&#34;Define fields on self.metadata.&#34;&#34;&#34;

        plaintiff: Optional[str] = None
        defendant: Optional[str] = None
        extra: Optional[str] = None
        antecedent_guess: Optional[str] = None
        # May be populated after citation resolution
        resolved_case_name_short: Optional[str] = None
        resolved_case_name: Optional[str] = None

    def add_metadata(self, document: &#34;Document&#34;):
        &#34;&#34;&#34;Extract metadata from text before and after citation.&#34;&#34;&#34;
        # pylint: disable=import-outside-toplevel
        from eyecite.helpers import (
            add_post_citation,
            add_pre_citation,
            find_case_name,
            find_case_name_in_html,
        )

        add_post_citation(self, document.words)

        if document.markup_text:
            find_case_name_in_html(self, document)
            if self.metadata.defendant is None:
                find_case_name(self, document)

        else:
            find_case_name(self, document)

        add_pre_citation(self, document)
        self.guess_court()
        super().add_metadata(document)

    def corrected_citation_full(self):
        &#34;&#34;&#34;Return formatted version of extracted cite.&#34;&#34;&#34;
        parts = []
        m = self.metadata
        if m.plaintiff:
            parts.append(f&#34;{m.plaintiff} v. &#34;)
        if m.defendant:
            parts.append(f&#34;{m.defendant}, &#34;)
        parts.append(self.corrected_citation())
        if m.pin_cite:
            parts.append(f&#34;, {m.pin_cite}&#34;)
        if m.extra:
            parts.append(m.extra)
        publisher_date = &#34; &#34;.join(i for i in (m.court, m.year) if i)
        if publisher_date:
            parts.append(f&#34; ({publisher_date})&#34;)
        if m.parenthetical:
            parts.append(f&#34; ({m.parenthetical})&#34;)
        return &#34;&#34;.join(parts)


@dataclass(eq=False, unsafe_hash=False, repr=False)
class ShortCaseCitation(CaseCitation):
    &#34;&#34;&#34;Convenience class which represents a short form citation, i.e., the kind
    of citation made after a full citation has already appeared. This kind of
    citation lacks a full case name and usually has a different page number
    than the canonical citation.

    Examples:
    ```
    Adarand, 515 U.S., at 241
    Adarand, 515 U.S. at 241
    515 U.S., at 241
    ```
    &#34;&#34;&#34;

    @dataclass(eq=True, unsafe_hash=True)
    class Metadata(CaseCitation.Metadata):
        &#34;&#34;&#34;Define fields on self.metadata.&#34;&#34;&#34;

        antecedent_guess: Optional[str] = None

    def corrected_citation_full(self):
        &#34;&#34;&#34;Return formatted version of extracted cite.&#34;&#34;&#34;
        parts = []
        if self.metadata.antecedent_guess:
            parts.append(f&#34;{self.metadata.antecedent_guess}, &#34;)
        parts.append(self.corrected_citation())
        return &#34;&#34;.join(parts)


@dataclass(eq=False, unsafe_hash=False, repr=False)
class SupraCitation(CitationBase):
    &#34;&#34;&#34;Convenience class which represents a &#39;supra&#39; citation, i.e., a citation
    to something that is above in the document. Like a short form citation,
    this kind of citation lacks a full case name and usually has a different
    page number than the canonical citation.


    Examples:
    ```
    Adarand, supra, at 240
    Adarand, 515 supra, at 240
    Adarand, supra, somethingelse
    Adarand, supra. somethingelse
    ```
    &#34;&#34;&#34;

    @dataclass(eq=True, unsafe_hash=True)
    class Metadata(CitationBase.Metadata):
        &#34;&#34;&#34;Define fields on self.metadata.&#34;&#34;&#34;

        antecedent_guess: Optional[str] = None
        volume: Optional[str] = None

    def formatted(self):
        &#34;&#34;&#34;Return formatted version of extracted cite.&#34;&#34;&#34;
        parts = []
        m = self.metadata
        if m.antecedent_guess:
            parts.append(f&#34;{m.antecedent_guess}, &#34;)
        if m.volume:
            parts.append(f&#34;{m.volume} &#34;)
        parts.append(&#34;supra&#34;)
        if m.pin_cite:
            parts.append(f&#34;, {m.pin_cite}&#34;)
        return &#34;&#34;.join(parts)


@dataclass(eq=False, unsafe_hash=False, repr=False)
class IdCitation(CitationBase):
    &#34;&#34;&#34;Convenience class which represents an &#39;id&#39; or &#39;ibid&#39; citation, i.e., a
    citation to the document referenced immediately prior. An &#39;id&#39; citation is
    unlike a regular citation object since it has no knowledge of its reporter,
    volume, or page. Instead, the only helpful information that this reference
    possesses is a record of the pin cite after the &#39;id&#39; token.

    Example: &#34;... foo bar,&#34; id., at 240
    &#34;&#34;&#34;

    def __hash__(self) -&gt; int:
        &#34;&#34;&#34;IdCitation objects are always considered unique for safety.&#34;&#34;&#34;
        return id(self)

    @dataclass(eq=True, unsafe_hash=True)
    class Metadata(CitationBase.Metadata):
        &#34;&#34;&#34;Define fields on self.metadata.&#34;&#34;&#34;

        pass

    def formatted(self):
        &#34;&#34;&#34;Return formatted version of extracted cite.&#34;&#34;&#34;
        parts = [&#34;id.&#34;]
        if self.metadata.pin_cite:
            parts.append(f&#34;, {self.metadata.pin_cite}&#34;)
        return &#34;&#34;.join(parts)


@dataclass(eq=False, unsafe_hash=False, repr=False)
class ReferenceCitation(CitationBase):
    &#34;&#34;&#34;A reference citation is a citation that refers to
    a full case citation by name and pincite alone.

    Future versions hopefully with drop the pincite requirement

    Examples:
    Roe at 240
    &#34;&#34;&#34;

    @dataclass(eq=True, unsafe_hash=True)
    class Metadata(CitationBase.Metadata):
        &#34;&#34;&#34;Define fields on self.metadata.&#34;&#34;&#34;

        plaintiff: Optional[str] = None
        defendant: Optional[str] = None
        resolved_case_name_short: Optional[str] = None
        resolved_case_name: Optional[str] = None

    name_fields = [
        &#34;plaintiff&#34;,
        &#34;defendant&#34;,
        &#34;resolved_case_name_short&#34;,
        &#34;resolved_case_name&#34;,
    ]


@dataclass(eq=False, unsafe_hash=False, repr=False)
class UnknownCitation(CitationBase):
    &#34;&#34;&#34;Convenience class which represents an unknown citation. A recognized
    citation should theoretically be parsed as a CaseCitation, FullLawCitation,
    or a FullJournalCitation. If it&#39;s something else, this class serves as
    a naive catch-all.
    &#34;&#34;&#34;

    def __hash__(self) -&gt; int:
        &#34;&#34;&#34;UnknownCitation objects are always considered unique for safety.&#34;&#34;&#34;
        return id(self)


@dataclass(eq=True, unsafe_hash=True)
class Token(UserString):
    &#34;&#34;&#34;Base class for special tokens. For performance, this isn&#39;t used
    for generic words.&#34;&#34;&#34;

    data: str
    start: int
    end: int
    groups: dict = field(default_factory=dict, compare=False)

    @classmethod
    def from_match(cls, m, extra, offset=0) -&gt; &#34;Token&#34;:
        &#34;&#34;&#34;Return a token object based on a regular expression match.
        This gets called by TokenExtractor. By default, just use the
        entire matched string.&#34;&#34;&#34;
        start, end = m.span(1)
        # ignore &#34;too many arguments&#34; type error -- this is called
        # by subclasses with additional attributes
        return cls(  # type: ignore[call-arg]
            m[1], start + offset, end + offset, groups=m.groupdict(), **extra
        )

    def merge(self, other: &#34;Token&#34;) -&gt; Optional[&#34;Token&#34;]:
        &#34;&#34;&#34;Merge two tokens, by returning self if other is identical to
        self.&#34;&#34;&#34;
        if (
            self.start == other.start
            and self.end == other.end
            and type(self) is type(other)
            and self.groups == other.groups
        ):
            return self
        return None


# For performance, lists of tokens can include either Token subclasses
# or bare strings (the typical case of words that aren&#39;t
# related to citations)
TokenOrStr = Union[Token, str]
Tokens = List[TokenOrStr]


@dataclass(eq=True, unsafe_hash=True)
class CitationToken(Token):
    &#34;&#34;&#34;String matching a citation regex from `reporters_db/reporters.json`.&#34;&#34;&#34;

    exact_editions: Sequence[Edition] = field(default_factory=tuple)
    variation_editions: Sequence[Edition] = field(default_factory=tuple)
    short: bool = False

    def __post_init__(self):
        &#34;&#34;&#34;Make iterables into tuples to make sure we&#39;re hashable.&#34;&#34;&#34;
        self.exact_editions = tuple(self.exact_editions)
        self.variation_editions = tuple(self.variation_editions)

    def merge(self, other: &#34;Token&#34;) -&gt; Optional[&#34;Token&#34;]:
        &#34;&#34;&#34;To merge citation tokens, also make sure `short` matches,
        and combine their editions.&#34;&#34;&#34;
        merged = super().merge(other)
        if merged:
            other = cast(CitationToken, other)
            if self.short == other.short:
                self.exact_editions = cast(tuple, self.exact_editions) + cast(
                    tuple, other.exact_editions
                )
                self.variation_editions = cast(
                    tuple, self.variation_editions
                ) + cast(tuple, other.variation_editions)
                # Remove duplicate editions after merge
                self.exact_editions = tuple(set(self.exact_editions))
                self.variation_editions = tuple(set(self.variation_editions))
                return self
        return None


@dataclass(eq=True, unsafe_hash=True)
class SectionToken(Token):
    &#34;&#34;&#34;Word containing a section symbol.&#34;&#34;&#34;


@dataclass(eq=True, unsafe_hash=True)
class SupraToken(Token):
    &#34;&#34;&#34;Word matching &#34;supra&#34; with or without punctuation.&#34;&#34;&#34;


@dataclass(eq=True, unsafe_hash=True)
class IdToken(Token):
    &#34;&#34;&#34;Word matching &#34;id&#34; or &#34;ibid&#34;.&#34;&#34;&#34;


@dataclass(eq=True, unsafe_hash=True)
class ParagraphToken(Token):
    &#34;&#34;&#34;Word matching a break between paragraphs.&#34;&#34;&#34;


@dataclass(eq=True, unsafe_hash=True)
class StopWordToken(Token):
    &#34;&#34;&#34;Word matching one of the STOP_TOKENS.&#34;&#34;&#34;


@dataclass(eq=True, unsafe_hash=True)
class PlaceholderCitationToken(Token):
    &#34;&#34;&#34;Placeholder Citation Tokens.&#34;&#34;&#34;


@dataclass(eq=True, unsafe_hash=True)
class CaseReferenceToken(Token):
    &#34;&#34;&#34;Word matching plaintiff or defendant in a full case citation&#34;&#34;&#34;


@dataclass
class TokenExtractor:
    &#34;&#34;&#34;Class for extracting all matches from a given string for the given
    regex, and then for returning Token objects for all matches.&#34;&#34;&#34;

    regex: str
    # constructor should be Callable[[re.Match, dict, int], Token]
    # but this issue makes it inconvenient to specify the input types:
    # https://github.com/python/mypy/issues/5485
    constructor: Callable[..., Token]
    extra: Dict = field(default_factory=dict)
    flags: int = 0
    strings: List = field(default_factory=list)

    def get_matches(self, text):
        &#34;&#34;&#34;Return match objects for all matches in text.&#34;&#34;&#34;
        return self.compiled_regex.finditer(text)

    def get_token(self, m, offset=0) -&gt; Token:
        &#34;&#34;&#34;For a given match object, return a Token.&#34;&#34;&#34;
        return self.constructor(m, self.extra, offset)

    def __hash__(self):
        &#34;&#34;&#34;This needs to be hashable so we can remove redundant
        extractors returned by the pyahocorasick filter.&#34;&#34;&#34;
        return hash(repr(self))

    @property
    def compiled_regex(self):
        &#34;&#34;&#34;Cache compiled regex as a property.&#34;&#34;&#34;
        if not hasattr(self, &#34;_compiled_regex&#34;):
            self._compiled_regex = re.compile(self.regex, flags=self.flags)
        return self._compiled_regex


@dataclass(frozen=True)
class Resource(ResourceType):
    &#34;&#34;&#34;Thin resource class representing an object to which a citation can be
    resolved. See `eyecite.resolve` for more details.&#34;&#34;&#34;

    citation: FullCitation

    def __hash__(self):
        &#34;&#34;&#34;Resources are the same if their citations are semantically
        equivalent, as defined by their hash function.

        Note: Resources composed of citations with missing page numbers are
        NOT considered the same, even if their other attributes are identical.
        This is to avoid potential false positives.
        &#34;&#34;&#34;
        return hash(
            hash_sha256(
                {
                    &#34;citation&#34;: hash(self.citation),
                    &#34;class&#34;: type(self).__name__,
                }
            )
        )

    def __eq__(self, other):
        return self.__hash__() == other.__hash__()


@dataclass(eq=False, unsafe_hash=False)
class Document:
    &#34;&#34;&#34;A class to encapsulate the source text and the pre-processing applied to
    it before citation parsing

    If the source text comes from `markup_text`, SpanUpdater objects are
    created to help on citation parsing
    &#34;&#34;&#34;

    plain_text: str = &#34;&#34;
    markup_text: Optional[str] = &#34;&#34;
    citation_tokens: list[Tuple[int, Token]] = field(default_factory=list)
    words: Tokens = field(default_factory=list)
    plain_to_markup: Optional[SpanUpdater] = field(default=None, init=False)
    markup_to_plain: Optional[SpanUpdater] = field(default=None, init=False)
    clean_steps: Optional[Iterable[Union[str, Callable[[str], str]]]] = field(
        default_factory=list
    )
    emphasis_tags: List[Tuple[str, int, int]] = field(default_factory=list)
    source_text: str = &#34;&#34;  # will be useful for the annotation step

    def __post_init__(self):
        if self.plain_text and not self.markup_text:
            self.source_text = self.plain_text
            if self.clean_steps:
                self.plain_text = clean_text(self.plain_text, self.clean_steps)

        elif self.markup_text and not self.plain_text:
            self.source_text = self.markup_text

            if &#34;html&#34; not in self.clean_steps:
                self.clean_steps.insert(&#34;html&#34;, 0)
                logger.warning(
                    &#34;`html` has been added to `markup_text` clean_steps list&#34;
                )

            self.plain_text = clean_text(self.markup_text, self.clean_steps)

            self.plain_to_markup = SpanUpdater(
                self.plain_text, self.markup_text
            )
            self.markup_to_plain = SpanUpdater(
                self.markup_text, self.plain_text
            )

            self.identify_emphasis_tags()

        elif not self.markup_text and not self.plain_text:
            raise ValueError(&#34;Both `markup_text` and `plain_text` are empty&#34;)

        elif self.plain_text and self.markup_text:
            # both arguments were passed, we assume that `plain_text` is the
            # cleaned version of `markup_text`
            if self.clean_steps:
                raise ValueError(
                    &#34;Both `markup_text` and `plain_text` were passed. &#34;
                    &#34;Not clear which to apply `clean_steps` to&#34;
                )

            self.source_text = self.markup_text

    def identify_emphasis_tags(self):
        pattern = re.compile(
            r&#34;&lt;(em|i)[^&gt;]*&gt;(.*?)&lt;/\1&gt;&#34;, re.IGNORECASE | re.DOTALL
        )
        self.emphasis_tags = [
            (m.group(2).strip(), m.start(), m.end())
            for m in pattern.finditer(self.markup_text)
        ]

    def tokenize(self, tokenizer):
        &#34;&#34;&#34;Tokenize the document and store the results in the document
        object&#34;&#34;&#34;
        self.words, self.citation_tokens = tokenizer.tokenize(self.plain_text)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="eyecite.models.CaseCitation"><code class="flex name class">
<span>class <span class="ident">CaseCitation</span></span>
<span>(</span><span>token: <a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>, index: int, span_start: Optional[int] = None, span_end: Optional[int] = None, full_span_start: Optional[int] = None, full_span_end: Optional[int] = None, groups: dict = &lt;factory&gt;, metadata: Any = None, document: Optional[ForwardRef('<a title="eyecite.models.Document" href="#eyecite.models.Document">Document</a>')] = None, exact_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, variation_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, all_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, edition_guess: Optional[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = None, year: Optional[int] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience class which represents a single citation found in a
document.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, unsafe_hash=False, repr=False)
class CaseCitation(ResourceCitation):
    &#34;&#34;&#34;Convenience class which represents a single citation found in a
    document.
    &#34;&#34;&#34;

    def __hash__(self) -&gt; int:
        &#34;&#34;&#34;CaseCitation objects that have the same volume, reporter, and page
        are considered equivalent, unless the citation is missing a page, in
        which case the object&#39;s hash will be unique for safety.

        self.groups for CaseCitation objects usually contains these keys:
        - page (guaranteed here: https://github.com/freelawproject/reporters-db/blob/main/tests.py#L129)  # noqa: E501
        - reporter (guaranteed here: https://github.com/freelawproject/reporters-db/blob/main/tests.py#L129)  # noqa: E501
        - volume (almost always present, but some tax court citations don&#39;t have volumes)  # noqa: E501
        - reporter_nominative (sometimes)
        - volumes_nominative (sometimes)
        &#34;&#34;&#34;
        if self.groups[&#34;page&#34;] is None:
            return id(self)
        else:
            return hash(
                hash_sha256(
                    {
                        **{
                            k: self.groups[k]
                            for k in [&#34;volume&#34;, &#34;page&#34;]
                            if k in self.groups
                        },
                        **{
                            &#34;reporter&#34;: self.corrected_reporter(),
                            &#34;class&#34;: type(self).__name__,
                        },
                    }
                )
            )

    @dataclass(eq=True, unsafe_hash=True)
    class Metadata(FullCitation.Metadata):
        &#34;&#34;&#34;Define fields on self.metadata.&#34;&#34;&#34;

        # court is included for ShortCaseCitation as well. It won&#39;t appear in
        # the cite itself but can also be guessed from the reporter
        court: Optional[str] = None

    def guess_court(self):
        &#34;&#34;&#34;Set court based on reporter.&#34;&#34;&#34;
        if not self.metadata.court and any(
            e.reporter.is_scotus for e in self.all_editions
        ):
            self.metadata.court = &#34;scotus&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eyecite.models.ResourceCitation" href="#eyecite.models.ResourceCitation">ResourceCitation</a></li>
<li><a title="eyecite.models.CitationBase" href="#eyecite.models.CitationBase">CitationBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="eyecite.models.FullCaseCitation" href="#eyecite.models.FullCaseCitation">FullCaseCitation</a></li>
<li><a title="eyecite.models.ShortCaseCitation" href="#eyecite.models.ShortCaseCitation">ShortCaseCitation</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="eyecite.models.CaseCitation.guess_court"><code class="name flex">
<span>def <span class="ident">guess_court</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set court based on reporter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def guess_court(self):
    &#34;&#34;&#34;Set court based on reporter.&#34;&#34;&#34;
    if not self.metadata.court and any(
        e.reporter.is_scotus for e in self.all_editions
    ):
        self.metadata.court = &#34;scotus&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="eyecite.models.ResourceCitation" href="#eyecite.models.ResourceCitation">ResourceCitation</a></b></code>:
<ul class="hlist">
<li><code><a title="eyecite.models.ResourceCitation.Metadata" href="#eyecite.models.CitationBase.Metadata">Metadata</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.add_metadata" href="#eyecite.models.ResourceCitation.add_metadata">add_metadata</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.corrected_citation" href="#eyecite.models.ResourceCitation.corrected_citation">corrected_citation</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.corrected_citation_full" href="#eyecite.models.CitationBase.corrected_citation_full">corrected_citation_full</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.corrected_page" href="#eyecite.models.ResourceCitation.corrected_page">corrected_page</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.corrected_reporter" href="#eyecite.models.ResourceCitation.corrected_reporter">corrected_reporter</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.dump" href="#eyecite.models.CitationBase.dump">dump</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.full_span" href="#eyecite.models.CitationBase.full_span">full_span</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.guess_edition" href="#eyecite.models.ResourceCitation.guess_edition">guess_edition</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.matched_text" href="#eyecite.models.CitationBase.matched_text">matched_text</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.span" href="#eyecite.models.CitationBase.span">span</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.span_with_pincite" href="#eyecite.models.CitationBase.span_with_pincite">span_with_pincite</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="eyecite.models.CaseReferenceToken"><code class="flex name class">
<span>class <span class="ident">CaseReferenceToken</span></span>
<span>(</span><span>data: str, start: int, end: int, groups: dict = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Word matching plaintiff or defendant in a full case citation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=True, unsafe_hash=True)
class CaseReferenceToken(Token):
    &#34;&#34;&#34;Word matching plaintiff or defendant in a full case citation&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a></li>
<li>collections.UserString</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a></b></code>:
<ul class="hlist">
<li><code><a title="eyecite.models.Token.from_match" href="#eyecite.models.Token.from_match">from_match</a></code></li>
<li><code><a title="eyecite.models.Token.merge" href="#eyecite.models.Token.merge">merge</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="eyecite.models.CitationBase"><code class="flex name class">
<span>class <span class="ident">CitationBase</span></span>
<span>(</span><span>token: <a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>, index: int, span_start: Optional[int] = None, span_end: Optional[int] = None, full_span_start: Optional[int] = None, full_span_end: Optional[int] = None, groups: dict = &lt;factory&gt;, metadata: Any = None, document: Optional[ForwardRef('<a title="eyecite.models.Document" href="#eyecite.models.Document">Document</a>')] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for objects returned by <code><a title="eyecite.find.get_citations" href="find.html#eyecite.find.get_citations">get_citations()</a></code>. We
define several subclasses of this class below, representing the various
types of citations that might exist.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, unsafe_hash=False)
class CitationBase:
    &#34;&#34;&#34;Base class for objects returned by `eyecite.find.get_citations`. We
    define several subclasses of this class below, representing the various
    types of citations that might exist.&#34;&#34;&#34;

    token: &#34;Token&#34;  # token this citation came from
    index: int  # index of _token in the token list
    # span() overrides
    span_start: Optional[int] = None
    span_end: Optional[int] = None
    full_span_start: Optional[int] = None
    full_span_end: Optional[int] = None
    groups: dict = field(default_factory=dict)
    metadata: Any = None
    document: Optional[&#34;Document&#34;] = None

    def __post_init__(self):
        &#34;&#34;&#34;Set up groups and metadata.&#34;&#34;&#34;
        # Allow groups to be used in comparisons:
        self.groups = self.token.groups
        # Make metadata a self.Metadata object:
        self.metadata = (
            self.Metadata(**self.metadata)
            if isinstance(self.metadata, dict)
            else self.Metadata()
        )
        # Set known missing page numbers to None
        if re.search(&#34;^_+$&#34;, self.groups.get(&#34;page&#34;, &#34;&#34;) or &#34;&#34;):
            self.groups[&#34;page&#34;] = None

    def __repr__(self):
        &#34;&#34;&#34;Simplified repr() to be more readable than full dataclass repr().
        Just shows &#39;FullCaseCitation(&#34;matched text&#34;, groups=...)&#39;.&#34;&#34;&#34;
        return (
            f&#34;{self.__class__.__name__}(&#34;
            + f&#34;{repr(self.matched_text())}&#34;
            + (f&#34;, groups={repr(self.groups)}&#34; if self.groups else &#34;&#34;)
            + f&#34;, metadata={repr(self.metadata)}&#34;
            + &#34;)&#34;
        )

    def __hash__(self) -&gt; int:
        &#34;&#34;&#34;In general, citations are considered equivalent if they have the
        same group values (i.e., the same regex group content that is extracted
        from the matched text). Subclasses may override this method in order to
        specify equivalence behavior that is more appropriate for certain
        kinds of citations (e.g., see CaseCitation override).

        self.groups typically contains different keys for different objects:

        FullLawCitation (non-exhaustive and non-guaranteed):
        - chapter
        - reporter
        - law_section
        - issue
        - page
        - docket_number
        - pamphlet
        - title

        FullJournalCitation (non-exhaustive and non-guaranteed):
        - volume
        - reporter
        - page

        FullCaseCitation (see CaseCitation.__hash__() notes)
        &#34;&#34;&#34;
        return hash(
            hash_sha256(
                {**dict(self.groups.items()), **{&#34;class&#34;: type(self).__name__}}
            )
        )

    def __eq__(self, other):
        &#34;&#34;&#34;This method is inherited by all subclasses and should not be
        overridden. It implements object equality in exactly the same way as
        defined in an object&#39;s __hash__() function, which should be overridden
        instead if desired.
        &#34;&#34;&#34;
        return self.__hash__() == other.__hash__()

    @dataclass(eq=True, unsafe_hash=True)
    class Metadata:
        &#34;&#34;&#34;Define fields on self.metadata.&#34;&#34;&#34;

        parenthetical: Optional[str] = None
        pin_cite: Optional[str] = None
        pin_cite_span_start: Optional[int] = None
        pin_cite_span_end: Optional[int] = None

    def corrected_citation(self):
        &#34;&#34;&#34;Return citation with any variations normalized.&#34;&#34;&#34;
        return self.matched_text()

    def corrected_citation_full(self):
        &#34;&#34;&#34;Return citation with any variations normalized, including extracted
        metadata if any.&#34;&#34;&#34;
        return self.matched_text()

    def dump(self) -&gt; dict:
        &#34;&#34;&#34;Return citation data for printing by dump_citations.&#34;&#34;&#34;
        return {
            &#34;groups&#34;: self.groups,
            &#34;metadata&#34;: {
                k: v
                for k, v in self.metadata.__dict__.items()
                if v is not None
            },
        }

    def matched_text(self):
        &#34;&#34;&#34;Text that identified this citation, such as &#39;1 U.S. 1&#39; or &#39;Id.&#39;&#34;&#34;&#34;
        return str(self.token)

    def span(self):
        &#34;&#34;&#34;Start and stop offsets in source text for matched_text().&#34;&#34;&#34;
        return (
            (
                self.span_start
                if self.span_start is not None
                else self.token.start
            ),
            self.span_end if self.span_end is not None else self.token.end,
        )

    def span_with_pincite(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Start and stop offsets in source text for pin cites.&#34;&#34;&#34;
        start = min(
            list(
                filter(
                    lambda v: v is not None,
                    [
                        self.metadata.pin_cite_span_start,
                        self.span_start,
                        self.token.start,
                    ],
                )
            ),
            default=self.token.start,
        )

        end = max(
            list(
                filter(
                    lambda v: v is not None,
                    [
                        self.metadata.pin_cite_span_end,
                        self.token.end,
                        self.span_end,
                    ],
                )
            ),
            default=self.token.end,
        )

        return (start, end)

    def full_span(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Span indices that fully cover the citation

        Start and stop offsets in source text for full citation text (including
        plaintiff, defendant, post citation, ...)

        Relevant for FullCaseCitation, FullJournalCitation and FullLawCitation.

        :returns: Tuple of start and end indicies
        &#34;&#34;&#34;
        start = self.full_span_start
        if start is None:
            start = self.span()[0]

        end = self.full_span_end
        if end is None:
            end = self.span()[1]

        return start, end</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="eyecite.models.IdCitation" href="#eyecite.models.IdCitation">IdCitation</a></li>
<li><a title="eyecite.models.ReferenceCitation" href="#eyecite.models.ReferenceCitation">ReferenceCitation</a></li>
<li><a title="eyecite.models.ResourceCitation" href="#eyecite.models.ResourceCitation">ResourceCitation</a></li>
<li><a title="eyecite.models.SupraCitation" href="#eyecite.models.SupraCitation">SupraCitation</a></li>
<li><a title="eyecite.models.UnknownCitation" href="#eyecite.models.UnknownCitation">UnknownCitation</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="eyecite.models.CitationBase.Metadata"><code class="name">var <span class="ident">Metadata</span></code></dt>
<dd>
<div class="desc"><p>Define fields on self.metadata.</p></div>
</dd>
<dt id="eyecite.models.CitationBase.document"><code class="name">var <span class="ident">document</span> : Optional[<a title="eyecite.models.Document" href="#eyecite.models.Document">Document</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.CitationBase.full_span_end"><code class="name">var <span class="ident">full_span_end</span> : Optional[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.CitationBase.full_span_start"><code class="name">var <span class="ident">full_span_start</span> : Optional[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.CitationBase.groups"><code class="name">var <span class="ident">groups</span> : dict</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.CitationBase.index"><code class="name">var <span class="ident">index</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.CitationBase.metadata"><code class="name">var <span class="ident">metadata</span> : Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.CitationBase.span_end"><code class="name">var <span class="ident">span_end</span> : Optional[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.CitationBase.span_start"><code class="name">var <span class="ident">span_start</span> : Optional[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.CitationBase.token"><code class="name">var <span class="ident">token</span> : <a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="eyecite.models.CitationBase.corrected_citation"><code class="name flex">
<span>def <span class="ident">corrected_citation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return citation with any variations normalized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corrected_citation(self):
    &#34;&#34;&#34;Return citation with any variations normalized.&#34;&#34;&#34;
    return self.matched_text()</code></pre>
</details>
</dd>
<dt id="eyecite.models.CitationBase.corrected_citation_full"><code class="name flex">
<span>def <span class="ident">corrected_citation_full</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return citation with any variations normalized, including extracted
metadata if any.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corrected_citation_full(self):
    &#34;&#34;&#34;Return citation with any variations normalized, including extracted
    metadata if any.&#34;&#34;&#34;
    return self.matched_text()</code></pre>
</details>
</dd>
<dt id="eyecite.models.CitationBase.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Return citation data for printing by dump_citations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; dict:
    &#34;&#34;&#34;Return citation data for printing by dump_citations.&#34;&#34;&#34;
    return {
        &#34;groups&#34;: self.groups,
        &#34;metadata&#34;: {
            k: v
            for k, v in self.metadata.__dict__.items()
            if v is not None
        },
    }</code></pre>
</details>
</dd>
<dt id="eyecite.models.CitationBase.full_span"><code class="name flex">
<span>def <span class="ident">full_span</span></span>(<span>self) ‑> Tuple[int, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Span indices that fully cover the citation</p>
<p>Start and stop offsets in source text for full citation text (including
plaintiff, defendant, post citation, &hellip;)</p>
<p>Relevant for FullCaseCitation, FullJournalCitation and FullLawCitation.</p>
<p>:returns: Tuple of start and end indicies</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def full_span(self) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;Span indices that fully cover the citation

    Start and stop offsets in source text for full citation text (including
    plaintiff, defendant, post citation, ...)

    Relevant for FullCaseCitation, FullJournalCitation and FullLawCitation.

    :returns: Tuple of start and end indicies
    &#34;&#34;&#34;
    start = self.full_span_start
    if start is None:
        start = self.span()[0]

    end = self.full_span_end
    if end is None:
        end = self.span()[1]

    return start, end</code></pre>
</details>
</dd>
<dt id="eyecite.models.CitationBase.matched_text"><code class="name flex">
<span>def <span class="ident">matched_text</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Text that identified this citation, such as '1 U.S. 1' or 'Id.'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matched_text(self):
    &#34;&#34;&#34;Text that identified this citation, such as &#39;1 U.S. 1&#39; or &#39;Id.&#39;&#34;&#34;&#34;
    return str(self.token)</code></pre>
</details>
</dd>
<dt id="eyecite.models.CitationBase.span"><code class="name flex">
<span>def <span class="ident">span</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start and stop offsets in source text for matched_text().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def span(self):
    &#34;&#34;&#34;Start and stop offsets in source text for matched_text().&#34;&#34;&#34;
    return (
        (
            self.span_start
            if self.span_start is not None
            else self.token.start
        ),
        self.span_end if self.span_end is not None else self.token.end,
    )</code></pre>
</details>
</dd>
<dt id="eyecite.models.CitationBase.span_with_pincite"><code class="name flex">
<span>def <span class="ident">span_with_pincite</span></span>(<span>self) ‑> Tuple[int, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Start and stop offsets in source text for pin cites.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def span_with_pincite(self) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;Start and stop offsets in source text for pin cites.&#34;&#34;&#34;
    start = min(
        list(
            filter(
                lambda v: v is not None,
                [
                    self.metadata.pin_cite_span_start,
                    self.span_start,
                    self.token.start,
                ],
            )
        ),
        default=self.token.start,
    )

    end = max(
        list(
            filter(
                lambda v: v is not None,
                [
                    self.metadata.pin_cite_span_end,
                    self.token.end,
                    self.span_end,
                ],
            )
        ),
        default=self.token.end,
    )

    return (start, end)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="eyecite.models.CitationToken"><code class="flex name class">
<span>class <span class="ident">CitationToken</span></span>
<span>(</span><span>data: str, start: int, end: int, groups: dict = &lt;factory&gt;, exact_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, variation_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, short: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>String matching a citation regex from <code>reporters_db/reporters.json</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=True, unsafe_hash=True)
class CitationToken(Token):
    &#34;&#34;&#34;String matching a citation regex from `reporters_db/reporters.json`.&#34;&#34;&#34;

    exact_editions: Sequence[Edition] = field(default_factory=tuple)
    variation_editions: Sequence[Edition] = field(default_factory=tuple)
    short: bool = False

    def __post_init__(self):
        &#34;&#34;&#34;Make iterables into tuples to make sure we&#39;re hashable.&#34;&#34;&#34;
        self.exact_editions = tuple(self.exact_editions)
        self.variation_editions = tuple(self.variation_editions)

    def merge(self, other: &#34;Token&#34;) -&gt; Optional[&#34;Token&#34;]:
        &#34;&#34;&#34;To merge citation tokens, also make sure `short` matches,
        and combine their editions.&#34;&#34;&#34;
        merged = super().merge(other)
        if merged:
            other = cast(CitationToken, other)
            if self.short == other.short:
                self.exact_editions = cast(tuple, self.exact_editions) + cast(
                    tuple, other.exact_editions
                )
                self.variation_editions = cast(
                    tuple, self.variation_editions
                ) + cast(tuple, other.variation_editions)
                # Remove duplicate editions after merge
                self.exact_editions = tuple(set(self.exact_editions))
                self.variation_editions = tuple(set(self.variation_editions))
                return self
        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a></li>
<li>collections.UserString</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="eyecite.models.CitationToken.exact_editions"><code class="name">var <span class="ident">exact_editions</span> : Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.CitationToken.short"><code class="name">var <span class="ident">short</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.CitationToken.variation_editions"><code class="name">var <span class="ident">variation_editions</span> : Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="eyecite.models.CitationToken.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self, other: <a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>) ‑> Optional[<a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>To merge citation tokens, also make sure <code>short</code> matches,
and combine their editions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge(self, other: &#34;Token&#34;) -&gt; Optional[&#34;Token&#34;]:
    &#34;&#34;&#34;To merge citation tokens, also make sure `short` matches,
    and combine their editions.&#34;&#34;&#34;
    merged = super().merge(other)
    if merged:
        other = cast(CitationToken, other)
        if self.short == other.short:
            self.exact_editions = cast(tuple, self.exact_editions) + cast(
                tuple, other.exact_editions
            )
            self.variation_editions = cast(
                tuple, self.variation_editions
            ) + cast(tuple, other.variation_editions)
            # Remove duplicate editions after merge
            self.exact_editions = tuple(set(self.exact_editions))
            self.variation_editions = tuple(set(self.variation_editions))
            return self
    return None</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a></b></code>:
<ul class="hlist">
<li><code><a title="eyecite.models.Token.from_match" href="#eyecite.models.Token.from_match">from_match</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="eyecite.models.Document"><code class="flex name class">
<span>class <span class="ident">Document</span></span>
<span>(</span><span>plain_text: str = '', markup_text: Optional[str] = '', citation_tokens: list[typing.Tuple[int, <a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>]] = &lt;factory&gt;, words: List[Union[<a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>, str]] = &lt;factory&gt;, clean_steps: Optional[Iterable[Union[str, Callable[[str], str]]]] = &lt;factory&gt;, emphasis_tags: List[Tuple[str, int, int]] = &lt;factory&gt;, source_text: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>A class to encapsulate the source text and the pre-processing applied to
it before citation parsing</p>
<p>If the source text comes from <code>markup_text</code>, SpanUpdater objects are
created to help on citation parsing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, unsafe_hash=False)
class Document:
    &#34;&#34;&#34;A class to encapsulate the source text and the pre-processing applied to
    it before citation parsing

    If the source text comes from `markup_text`, SpanUpdater objects are
    created to help on citation parsing
    &#34;&#34;&#34;

    plain_text: str = &#34;&#34;
    markup_text: Optional[str] = &#34;&#34;
    citation_tokens: list[Tuple[int, Token]] = field(default_factory=list)
    words: Tokens = field(default_factory=list)
    plain_to_markup: Optional[SpanUpdater] = field(default=None, init=False)
    markup_to_plain: Optional[SpanUpdater] = field(default=None, init=False)
    clean_steps: Optional[Iterable[Union[str, Callable[[str], str]]]] = field(
        default_factory=list
    )
    emphasis_tags: List[Tuple[str, int, int]] = field(default_factory=list)
    source_text: str = &#34;&#34;  # will be useful for the annotation step

    def __post_init__(self):
        if self.plain_text and not self.markup_text:
            self.source_text = self.plain_text
            if self.clean_steps:
                self.plain_text = clean_text(self.plain_text, self.clean_steps)

        elif self.markup_text and not self.plain_text:
            self.source_text = self.markup_text

            if &#34;html&#34; not in self.clean_steps:
                self.clean_steps.insert(&#34;html&#34;, 0)
                logger.warning(
                    &#34;`html` has been added to `markup_text` clean_steps list&#34;
                )

            self.plain_text = clean_text(self.markup_text, self.clean_steps)

            self.plain_to_markup = SpanUpdater(
                self.plain_text, self.markup_text
            )
            self.markup_to_plain = SpanUpdater(
                self.markup_text, self.plain_text
            )

            self.identify_emphasis_tags()

        elif not self.markup_text and not self.plain_text:
            raise ValueError(&#34;Both `markup_text` and `plain_text` are empty&#34;)

        elif self.plain_text and self.markup_text:
            # both arguments were passed, we assume that `plain_text` is the
            # cleaned version of `markup_text`
            if self.clean_steps:
                raise ValueError(
                    &#34;Both `markup_text` and `plain_text` were passed. &#34;
                    &#34;Not clear which to apply `clean_steps` to&#34;
                )

            self.source_text = self.markup_text

    def identify_emphasis_tags(self):
        pattern = re.compile(
            r&#34;&lt;(em|i)[^&gt;]*&gt;(.*?)&lt;/\1&gt;&#34;, re.IGNORECASE | re.DOTALL
        )
        self.emphasis_tags = [
            (m.group(2).strip(), m.start(), m.end())
            for m in pattern.finditer(self.markup_text)
        ]

    def tokenize(self, tokenizer):
        &#34;&#34;&#34;Tokenize the document and store the results in the document
        object&#34;&#34;&#34;
        self.words, self.citation_tokens = tokenizer.tokenize(self.plain_text)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="eyecite.models.Document.citation_tokens"><code class="name">var <span class="ident">citation_tokens</span> : list[typing.Tuple[int, <a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.Document.clean_steps"><code class="name">var <span class="ident">clean_steps</span> : Optional[Iterable[Union[str, Callable[[str], str]]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.Document.emphasis_tags"><code class="name">var <span class="ident">emphasis_tags</span> : List[Tuple[str, int, int]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.Document.markup_text"><code class="name">var <span class="ident">markup_text</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.Document.markup_to_plain"><code class="name">var <span class="ident">markup_to_plain</span> : Optional[eyecite.annotate.SpanUpdater]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.Document.plain_text"><code class="name">var <span class="ident">plain_text</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.Document.plain_to_markup"><code class="name">var <span class="ident">plain_to_markup</span> : Optional[eyecite.annotate.SpanUpdater]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.Document.source_text"><code class="name">var <span class="ident">source_text</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.Document.words"><code class="name">var <span class="ident">words</span> : List[Union[<a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>, str]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="eyecite.models.Document.identify_emphasis_tags"><code class="name flex">
<span>def <span class="ident">identify_emphasis_tags</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identify_emphasis_tags(self):
    pattern = re.compile(
        r&#34;&lt;(em|i)[^&gt;]*&gt;(.*?)&lt;/\1&gt;&#34;, re.IGNORECASE | re.DOTALL
    )
    self.emphasis_tags = [
        (m.group(2).strip(), m.start(), m.end())
        for m in pattern.finditer(self.markup_text)
    ]</code></pre>
</details>
</dd>
<dt id="eyecite.models.Document.tokenize"><code class="name flex">
<span>def <span class="ident">tokenize</span></span>(<span>self, tokenizer)</span>
</code></dt>
<dd>
<div class="desc"><p>Tokenize the document and store the results in the document
object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tokenize(self, tokenizer):
    &#34;&#34;&#34;Tokenize the document and store the results in the document
    object&#34;&#34;&#34;
    self.words, self.citation_tokens = tokenizer.tokenize(self.plain_text)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="eyecite.models.Edition"><code class="flex name class">
<span>class <span class="ident">Edition</span></span>
<span>(</span><span>reporter: <a title="eyecite.models.Reporter" href="#eyecite.models.Reporter">Reporter</a>, short_name: str, start: Optional[datetime.datetime], end: Optional[datetime.datetime])</span>
</code></dt>
<dd>
<div class="desc"><p>Class for individual editions in <code>reporters_db</code>,
like "S.W." and "S.W.2d".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=True, frozen=True)
class Edition:
    &#34;&#34;&#34;Class for individual editions in `reporters_db`,
    like &#34;S.W.&#34; and &#34;S.W.2d&#34;.&#34;&#34;&#34;

    reporter: Reporter
    short_name: str
    start: Optional[datetime]
    end: Optional[datetime]

    def includes_year(
        self,
        year: int,
    ) -&gt; bool:
        &#34;&#34;&#34;Return True if edition contains cases for the given year.&#34;&#34;&#34;
        return (
            year &lt;= datetime.now().year
            and (self.start is None or self.start.year &lt;= year)
            and (self.end is None or self.end.year &gt;= year)
        )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="eyecite.models.Edition.end"><code class="name">var <span class="ident">end</span> : Optional[datetime.datetime]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.Edition.reporter"><code class="name">var <span class="ident">reporter</span> : <a title="eyecite.models.Reporter" href="#eyecite.models.Reporter">Reporter</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.Edition.short_name"><code class="name">var <span class="ident">short_name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.Edition.start"><code class="name">var <span class="ident">start</span> : Optional[datetime.datetime]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="eyecite.models.Edition.includes_year"><code class="name flex">
<span>def <span class="ident">includes_year</span></span>(<span>self, year: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if edition contains cases for the given year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def includes_year(
    self,
    year: int,
) -&gt; bool:
    &#34;&#34;&#34;Return True if edition contains cases for the given year.&#34;&#34;&#34;
    return (
        year &lt;= datetime.now().year
        and (self.start is None or self.start.year &lt;= year)
        and (self.end is None or self.end.year &gt;= year)
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="eyecite.models.FullCaseCitation"><code class="flex name class">
<span>class <span class="ident">FullCaseCitation</span></span>
<span>(</span><span>token: <a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>, index: int, span_start: Optional[int] = None, span_end: Optional[int] = None, full_span_start: Optional[int] = None, full_span_end: Optional[int] = None, groups: dict = &lt;factory&gt;, metadata: Any = None, document: Optional[ForwardRef('<a title="eyecite.models.Document" href="#eyecite.models.Document">Document</a>')] = None, exact_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, variation_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, all_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, edition_guess: Optional[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = None, year: Optional[int] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience class which represents a standard, fully named citation,
i.e., the kind of citation that marks the first time a document is cited.</p>
<p>Example:</p>
<pre><code>Adarand Constructors, Inc. v. Peña, 515 U.S. 200, 240
Peña at 222, 515 U.S. 200
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, unsafe_hash=False, repr=False)
class FullCaseCitation(CaseCitation, FullCitation):
    &#34;&#34;&#34;Convenience class which represents a standard, fully named citation,
    i.e., the kind of citation that marks the first time a document is cited.

    Example:
    ```
    Adarand Constructors, Inc. v. Peña, 515 U.S. 200, 240
    Peña at 222, 515 U.S. 200
    ```
    &#34;&#34;&#34;

    def is_parallel_citation(self, preceding: CaseCitation):
        &#34;&#34;&#34;Check if preceding citation is parallel

        Args:
            preceding (): The previous citation found

        Returns: None
        &#34;&#34;&#34;
        if self.full_span_start == preceding.full_span_start:
            # if parallel get plaintiff/defendant data from
            # the earlier citation, since it won&#39;t be on the
            # parallel one.
            self.metadata.defendant = preceding.metadata.defendant
            self.metadata.plaintiff = preceding.metadata.plaintiff
            # California style may have a year prior to citation; merge as well
            self.metadata.year = preceding.metadata.year
            self.year = preceding.year

    @dataclass(eq=True, unsafe_hash=True)
    class Metadata(CaseCitation.Metadata):
        &#34;&#34;&#34;Define fields on self.metadata.&#34;&#34;&#34;

        plaintiff: Optional[str] = None
        defendant: Optional[str] = None
        extra: Optional[str] = None
        antecedent_guess: Optional[str] = None
        # May be populated after citation resolution
        resolved_case_name_short: Optional[str] = None
        resolved_case_name: Optional[str] = None

    def add_metadata(self, document: &#34;Document&#34;):
        &#34;&#34;&#34;Extract metadata from text before and after citation.&#34;&#34;&#34;
        # pylint: disable=import-outside-toplevel
        from eyecite.helpers import (
            add_post_citation,
            add_pre_citation,
            find_case_name,
            find_case_name_in_html,
        )

        add_post_citation(self, document.words)

        if document.markup_text:
            find_case_name_in_html(self, document)
            if self.metadata.defendant is None:
                find_case_name(self, document)

        else:
            find_case_name(self, document)

        add_pre_citation(self, document)
        self.guess_court()
        super().add_metadata(document)

    def corrected_citation_full(self):
        &#34;&#34;&#34;Return formatted version of extracted cite.&#34;&#34;&#34;
        parts = []
        m = self.metadata
        if m.plaintiff:
            parts.append(f&#34;{m.plaintiff} v. &#34;)
        if m.defendant:
            parts.append(f&#34;{m.defendant}, &#34;)
        parts.append(self.corrected_citation())
        if m.pin_cite:
            parts.append(f&#34;, {m.pin_cite}&#34;)
        if m.extra:
            parts.append(m.extra)
        publisher_date = &#34; &#34;.join(i for i in (m.court, m.year) if i)
        if publisher_date:
            parts.append(f&#34; ({publisher_date})&#34;)
        if m.parenthetical:
            parts.append(f&#34; ({m.parenthetical})&#34;)
        return &#34;&#34;.join(parts)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eyecite.models.CaseCitation" href="#eyecite.models.CaseCitation">CaseCitation</a></li>
<li><a title="eyecite.models.FullCitation" href="#eyecite.models.FullCitation">FullCitation</a></li>
<li><a title="eyecite.models.ResourceCitation" href="#eyecite.models.ResourceCitation">ResourceCitation</a></li>
<li><a title="eyecite.models.CitationBase" href="#eyecite.models.CitationBase">CitationBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="eyecite.models.FullCaseCitation.corrected_citation_full"><code class="name flex">
<span>def <span class="ident">corrected_citation_full</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return formatted version of extracted cite.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corrected_citation_full(self):
    &#34;&#34;&#34;Return formatted version of extracted cite.&#34;&#34;&#34;
    parts = []
    m = self.metadata
    if m.plaintiff:
        parts.append(f&#34;{m.plaintiff} v. &#34;)
    if m.defendant:
        parts.append(f&#34;{m.defendant}, &#34;)
    parts.append(self.corrected_citation())
    if m.pin_cite:
        parts.append(f&#34;, {m.pin_cite}&#34;)
    if m.extra:
        parts.append(m.extra)
    publisher_date = &#34; &#34;.join(i for i in (m.court, m.year) if i)
    if publisher_date:
        parts.append(f&#34; ({publisher_date})&#34;)
    if m.parenthetical:
        parts.append(f&#34; ({m.parenthetical})&#34;)
    return &#34;&#34;.join(parts)</code></pre>
</details>
</dd>
<dt id="eyecite.models.FullCaseCitation.is_parallel_citation"><code class="name flex">
<span>def <span class="ident">is_parallel_citation</span></span>(<span>self, preceding: <a title="eyecite.models.CaseCitation" href="#eyecite.models.CaseCitation">CaseCitation</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if preceding citation is parallel</p>
<h2 id="args">Args</h2>
<p>preceding (): The previous citation found
Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_parallel_citation(self, preceding: CaseCitation):
    &#34;&#34;&#34;Check if preceding citation is parallel

    Args:
        preceding (): The previous citation found

    Returns: None
    &#34;&#34;&#34;
    if self.full_span_start == preceding.full_span_start:
        # if parallel get plaintiff/defendant data from
        # the earlier citation, since it won&#39;t be on the
        # parallel one.
        self.metadata.defendant = preceding.metadata.defendant
        self.metadata.plaintiff = preceding.metadata.plaintiff
        # California style may have a year prior to citation; merge as well
        self.metadata.year = preceding.metadata.year
        self.year = preceding.year</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="eyecite.models.CaseCitation" href="#eyecite.models.CaseCitation">CaseCitation</a></b></code>:
<ul class="hlist">
<li><code><a title="eyecite.models.CaseCitation.Metadata" href="#eyecite.models.CitationBase.Metadata">Metadata</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.add_metadata" href="#eyecite.models.ResourceCitation.add_metadata">add_metadata</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.corrected_citation" href="#eyecite.models.ResourceCitation.corrected_citation">corrected_citation</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.corrected_page" href="#eyecite.models.ResourceCitation.corrected_page">corrected_page</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.corrected_reporter" href="#eyecite.models.ResourceCitation.corrected_reporter">corrected_reporter</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.dump" href="#eyecite.models.CitationBase.dump">dump</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.full_span" href="#eyecite.models.CitationBase.full_span">full_span</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.guess_court" href="#eyecite.models.CaseCitation.guess_court">guess_court</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.guess_edition" href="#eyecite.models.ResourceCitation.guess_edition">guess_edition</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.matched_text" href="#eyecite.models.CitationBase.matched_text">matched_text</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.span" href="#eyecite.models.CitationBase.span">span</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.span_with_pincite" href="#eyecite.models.CitationBase.span_with_pincite">span_with_pincite</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="eyecite.models.FullCitation"><code class="flex name class">
<span>class <span class="ident">FullCitation</span></span>
<span>(</span><span>token: <a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>, index: int, span_start: Optional[int] = None, span_end: Optional[int] = None, full_span_start: Optional[int] = None, full_span_end: Optional[int] = None, groups: dict = &lt;factory&gt;, metadata: Any = None, document: Optional[ForwardRef('<a title="eyecite.models.Document" href="#eyecite.models.Document">Document</a>')] = None, exact_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, variation_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, all_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, edition_guess: Optional[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = None, year: Optional[int] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class indicating that a citation fully identifies a
resource.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, unsafe_hash=False, repr=False)
class FullCitation(ResourceCitation):
    &#34;&#34;&#34;Abstract base class indicating that a citation fully identifies a
    resource.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eyecite.models.ResourceCitation" href="#eyecite.models.ResourceCitation">ResourceCitation</a></li>
<li><a title="eyecite.models.CitationBase" href="#eyecite.models.CitationBase">CitationBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="eyecite.models.FullCaseCitation" href="#eyecite.models.FullCaseCitation">FullCaseCitation</a></li>
<li><a title="eyecite.models.FullJournalCitation" href="#eyecite.models.FullJournalCitation">FullJournalCitation</a></li>
<li><a title="eyecite.models.FullLawCitation" href="#eyecite.models.FullLawCitation">FullLawCitation</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="eyecite.models.ResourceCitation" href="#eyecite.models.ResourceCitation">ResourceCitation</a></b></code>:
<ul class="hlist">
<li><code><a title="eyecite.models.ResourceCitation.Metadata" href="#eyecite.models.CitationBase.Metadata">Metadata</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.add_metadata" href="#eyecite.models.ResourceCitation.add_metadata">add_metadata</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.corrected_citation" href="#eyecite.models.ResourceCitation.corrected_citation">corrected_citation</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.corrected_citation_full" href="#eyecite.models.CitationBase.corrected_citation_full">corrected_citation_full</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.corrected_page" href="#eyecite.models.ResourceCitation.corrected_page">corrected_page</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.corrected_reporter" href="#eyecite.models.ResourceCitation.corrected_reporter">corrected_reporter</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.dump" href="#eyecite.models.CitationBase.dump">dump</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.full_span" href="#eyecite.models.CitationBase.full_span">full_span</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.guess_edition" href="#eyecite.models.ResourceCitation.guess_edition">guess_edition</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.matched_text" href="#eyecite.models.CitationBase.matched_text">matched_text</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.span" href="#eyecite.models.CitationBase.span">span</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.span_with_pincite" href="#eyecite.models.CitationBase.span_with_pincite">span_with_pincite</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="eyecite.models.FullJournalCitation"><code class="flex name class">
<span>class <span class="ident">FullJournalCitation</span></span>
<span>(</span><span>token: <a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>, index: int, span_start: Optional[int] = None, span_end: Optional[int] = None, full_span_start: Optional[int] = None, full_span_end: Optional[int] = None, groups: dict = &lt;factory&gt;, metadata: Any = None, document: Optional[ForwardRef('<a title="eyecite.models.Document" href="#eyecite.models.Document">Document</a>')] = None, exact_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, variation_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, all_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, edition_guess: Optional[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = None, year: Optional[int] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Citation to a source from <code>reporters_db/journals.json</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, unsafe_hash=False, repr=False)
class FullJournalCitation(FullCitation):
    &#34;&#34;&#34;Citation to a source from `reporters_db/journals.json`.&#34;&#34;&#34;

    def add_metadata(self, document: &#34;Document&#34;):
        &#34;&#34;&#34;Extract metadata from text before and after citation.&#34;&#34;&#34;
        # pylint: disable=import-outside-toplevel
        from eyecite.helpers import add_journal_metadata

        add_journal_metadata(self, document.words)
        super().add_metadata(document)

    def corrected_citation_full(self):
        &#34;&#34;&#34;Return citation with any variations normalized, including extracted
        metadata if any.&#34;&#34;&#34;
        parts = [self.corrected_citation()]
        m = self.metadata
        if m.pin_cite:
            parts.append(f&#34;, {m.pin_cite}&#34;)
        if m.year:
            parts.append(f&#34; ({m.year})&#34;)
        if m.parenthetical:
            parts.append(f&#34; ({m.parenthetical})&#34;)
        return &#34;&#34;.join(parts)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eyecite.models.FullCitation" href="#eyecite.models.FullCitation">FullCitation</a></li>
<li><a title="eyecite.models.ResourceCitation" href="#eyecite.models.ResourceCitation">ResourceCitation</a></li>
<li><a title="eyecite.models.CitationBase" href="#eyecite.models.CitationBase">CitationBase</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="eyecite.models.FullCitation" href="#eyecite.models.FullCitation">FullCitation</a></b></code>:
<ul class="hlist">
<li><code><a title="eyecite.models.FullCitation.Metadata" href="#eyecite.models.CitationBase.Metadata">Metadata</a></code></li>
<li><code><a title="eyecite.models.FullCitation.add_metadata" href="#eyecite.models.ResourceCitation.add_metadata">add_metadata</a></code></li>
<li><code><a title="eyecite.models.FullCitation.corrected_citation" href="#eyecite.models.ResourceCitation.corrected_citation">corrected_citation</a></code></li>
<li><code><a title="eyecite.models.FullCitation.corrected_citation_full" href="#eyecite.models.CitationBase.corrected_citation_full">corrected_citation_full</a></code></li>
<li><code><a title="eyecite.models.FullCitation.corrected_page" href="#eyecite.models.ResourceCitation.corrected_page">corrected_page</a></code></li>
<li><code><a title="eyecite.models.FullCitation.corrected_reporter" href="#eyecite.models.ResourceCitation.corrected_reporter">corrected_reporter</a></code></li>
<li><code><a title="eyecite.models.FullCitation.dump" href="#eyecite.models.CitationBase.dump">dump</a></code></li>
<li><code><a title="eyecite.models.FullCitation.full_span" href="#eyecite.models.CitationBase.full_span">full_span</a></code></li>
<li><code><a title="eyecite.models.FullCitation.guess_edition" href="#eyecite.models.ResourceCitation.guess_edition">guess_edition</a></code></li>
<li><code><a title="eyecite.models.FullCitation.matched_text" href="#eyecite.models.CitationBase.matched_text">matched_text</a></code></li>
<li><code><a title="eyecite.models.FullCitation.span" href="#eyecite.models.CitationBase.span">span</a></code></li>
<li><code><a title="eyecite.models.FullCitation.span_with_pincite" href="#eyecite.models.CitationBase.span_with_pincite">span_with_pincite</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="eyecite.models.FullLawCitation"><code class="flex name class">
<span>class <span class="ident">FullLawCitation</span></span>
<span>(</span><span>token: <a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>, index: int, span_start: Optional[int] = None, span_end: Optional[int] = None, full_span_start: Optional[int] = None, full_span_end: Optional[int] = None, groups: dict = &lt;factory&gt;, metadata: Any = None, document: Optional[ForwardRef('<a title="eyecite.models.Document" href="#eyecite.models.Document">Document</a>')] = None, exact_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, variation_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, all_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, edition_guess: Optional[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = None, year: Optional[int] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Citation to a source from <code>reporters_db/laws.json</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, unsafe_hash=False, repr=False)
class FullLawCitation(FullCitation):
    &#34;&#34;&#34;Citation to a source from `reporters_db/laws.json`.&#34;&#34;&#34;

    @dataclass(eq=True, unsafe_hash=True)
    class Metadata(FullCitation.Metadata):
        &#34;&#34;&#34;Define fields on self.metadata.&#34;&#34;&#34;

        publisher: Optional[str] = None
        day: Optional[str] = None
        month: Optional[str] = None

    def add_metadata(self, document: &#34;Document&#34;):
        &#34;&#34;&#34;Extract metadata from text before and after citation.&#34;&#34;&#34;
        # pylint: disable=import-outside-toplevel
        from eyecite.helpers import add_law_metadata

        add_law_metadata(self, document.words)
        super().add_metadata(document)

    def corrected_citation_full(self):
        &#34;&#34;&#34;Return citation with any variations normalized, including extracted
        metadata if any.&#34;&#34;&#34;
        parts = [self.corrected_citation()]
        m = self.metadata
        if m.pin_cite:
            parts.append(f&#34;{m.pin_cite}&#34;)
        publisher_date = &#34; &#34;.join(
            i for i in (m.publisher, m.month, m.day, m.year) if i
        )
        if publisher_date:
            parts.append(f&#34; ({publisher_date})&#34;)
        if m.parenthetical:
            parts.append(f&#34; ({m.parenthetical})&#34;)
        return &#34;&#34;.join(parts)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eyecite.models.FullCitation" href="#eyecite.models.FullCitation">FullCitation</a></li>
<li><a title="eyecite.models.ResourceCitation" href="#eyecite.models.ResourceCitation">ResourceCitation</a></li>
<li><a title="eyecite.models.CitationBase" href="#eyecite.models.CitationBase">CitationBase</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="eyecite.models.FullCitation" href="#eyecite.models.FullCitation">FullCitation</a></b></code>:
<ul class="hlist">
<li><code><a title="eyecite.models.FullCitation.Metadata" href="#eyecite.models.CitationBase.Metadata">Metadata</a></code></li>
<li><code><a title="eyecite.models.FullCitation.add_metadata" href="#eyecite.models.ResourceCitation.add_metadata">add_metadata</a></code></li>
<li><code><a title="eyecite.models.FullCitation.corrected_citation" href="#eyecite.models.ResourceCitation.corrected_citation">corrected_citation</a></code></li>
<li><code><a title="eyecite.models.FullCitation.corrected_citation_full" href="#eyecite.models.CitationBase.corrected_citation_full">corrected_citation_full</a></code></li>
<li><code><a title="eyecite.models.FullCitation.corrected_page" href="#eyecite.models.ResourceCitation.corrected_page">corrected_page</a></code></li>
<li><code><a title="eyecite.models.FullCitation.corrected_reporter" href="#eyecite.models.ResourceCitation.corrected_reporter">corrected_reporter</a></code></li>
<li><code><a title="eyecite.models.FullCitation.dump" href="#eyecite.models.CitationBase.dump">dump</a></code></li>
<li><code><a title="eyecite.models.FullCitation.full_span" href="#eyecite.models.CitationBase.full_span">full_span</a></code></li>
<li><code><a title="eyecite.models.FullCitation.guess_edition" href="#eyecite.models.ResourceCitation.guess_edition">guess_edition</a></code></li>
<li><code><a title="eyecite.models.FullCitation.matched_text" href="#eyecite.models.CitationBase.matched_text">matched_text</a></code></li>
<li><code><a title="eyecite.models.FullCitation.span" href="#eyecite.models.CitationBase.span">span</a></code></li>
<li><code><a title="eyecite.models.FullCitation.span_with_pincite" href="#eyecite.models.CitationBase.span_with_pincite">span_with_pincite</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="eyecite.models.IdCitation"><code class="flex name class">
<span>class <span class="ident">IdCitation</span></span>
<span>(</span><span>token: <a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>, index: int, span_start: Optional[int] = None, span_end: Optional[int] = None, full_span_start: Optional[int] = None, full_span_end: Optional[int] = None, groups: dict = &lt;factory&gt;, metadata: Any = None, document: Optional[ForwardRef('<a title="eyecite.models.Document" href="#eyecite.models.Document">Document</a>')] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience class which represents an 'id' or 'ibid' citation, i.e., a
citation to the document referenced immediately prior. An 'id' citation is
unlike a regular citation object since it has no knowledge of its reporter,
volume, or page. Instead, the only helpful information that this reference
possesses is a record of the pin cite after the 'id' token.</p>
<p>Example: "&hellip; foo bar," id., at 240</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, unsafe_hash=False, repr=False)
class IdCitation(CitationBase):
    &#34;&#34;&#34;Convenience class which represents an &#39;id&#39; or &#39;ibid&#39; citation, i.e., a
    citation to the document referenced immediately prior. An &#39;id&#39; citation is
    unlike a regular citation object since it has no knowledge of its reporter,
    volume, or page. Instead, the only helpful information that this reference
    possesses is a record of the pin cite after the &#39;id&#39; token.

    Example: &#34;... foo bar,&#34; id., at 240
    &#34;&#34;&#34;

    def __hash__(self) -&gt; int:
        &#34;&#34;&#34;IdCitation objects are always considered unique for safety.&#34;&#34;&#34;
        return id(self)

    @dataclass(eq=True, unsafe_hash=True)
    class Metadata(CitationBase.Metadata):
        &#34;&#34;&#34;Define fields on self.metadata.&#34;&#34;&#34;

        pass

    def formatted(self):
        &#34;&#34;&#34;Return formatted version of extracted cite.&#34;&#34;&#34;
        parts = [&#34;id.&#34;]
        if self.metadata.pin_cite:
            parts.append(f&#34;, {self.metadata.pin_cite}&#34;)
        return &#34;&#34;.join(parts)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eyecite.models.CitationBase" href="#eyecite.models.CitationBase">CitationBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="eyecite.models.IdCitation.formatted"><code class="name flex">
<span>def <span class="ident">formatted</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return formatted version of extracted cite.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formatted(self):
    &#34;&#34;&#34;Return formatted version of extracted cite.&#34;&#34;&#34;
    parts = [&#34;id.&#34;]
    if self.metadata.pin_cite:
        parts.append(f&#34;, {self.metadata.pin_cite}&#34;)
    return &#34;&#34;.join(parts)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="eyecite.models.CitationBase" href="#eyecite.models.CitationBase">CitationBase</a></b></code>:
<ul class="hlist">
<li><code><a title="eyecite.models.CitationBase.Metadata" href="#eyecite.models.CitationBase.Metadata">Metadata</a></code></li>
<li><code><a title="eyecite.models.CitationBase.corrected_citation" href="#eyecite.models.CitationBase.corrected_citation">corrected_citation</a></code></li>
<li><code><a title="eyecite.models.CitationBase.corrected_citation_full" href="#eyecite.models.CitationBase.corrected_citation_full">corrected_citation_full</a></code></li>
<li><code><a title="eyecite.models.CitationBase.dump" href="#eyecite.models.CitationBase.dump">dump</a></code></li>
<li><code><a title="eyecite.models.CitationBase.full_span" href="#eyecite.models.CitationBase.full_span">full_span</a></code></li>
<li><code><a title="eyecite.models.CitationBase.matched_text" href="#eyecite.models.CitationBase.matched_text">matched_text</a></code></li>
<li><code><a title="eyecite.models.CitationBase.span" href="#eyecite.models.CitationBase.span">span</a></code></li>
<li><code><a title="eyecite.models.CitationBase.span_with_pincite" href="#eyecite.models.CitationBase.span_with_pincite">span_with_pincite</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="eyecite.models.IdToken"><code class="flex name class">
<span>class <span class="ident">IdToken</span></span>
<span>(</span><span>data: str, start: int, end: int, groups: dict = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Word matching "id" or "ibid".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=True, unsafe_hash=True)
class IdToken(Token):
    &#34;&#34;&#34;Word matching &#34;id&#34; or &#34;ibid&#34;.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a></li>
<li>collections.UserString</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a></b></code>:
<ul class="hlist">
<li><code><a title="eyecite.models.Token.from_match" href="#eyecite.models.Token.from_match">from_match</a></code></li>
<li><code><a title="eyecite.models.Token.merge" href="#eyecite.models.Token.merge">merge</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="eyecite.models.ParagraphToken"><code class="flex name class">
<span>class <span class="ident">ParagraphToken</span></span>
<span>(</span><span>data: str, start: int, end: int, groups: dict = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Word matching a break between paragraphs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=True, unsafe_hash=True)
class ParagraphToken(Token):
    &#34;&#34;&#34;Word matching a break between paragraphs.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a></li>
<li>collections.UserString</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a></b></code>:
<ul class="hlist">
<li><code><a title="eyecite.models.Token.from_match" href="#eyecite.models.Token.from_match">from_match</a></code></li>
<li><code><a title="eyecite.models.Token.merge" href="#eyecite.models.Token.merge">merge</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="eyecite.models.PlaceholderCitationToken"><code class="flex name class">
<span>class <span class="ident">PlaceholderCitationToken</span></span>
<span>(</span><span>data: str, start: int, end: int, groups: dict = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Placeholder Citation Tokens.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=True, unsafe_hash=True)
class PlaceholderCitationToken(Token):
    &#34;&#34;&#34;Placeholder Citation Tokens.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a></li>
<li>collections.UserString</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a></b></code>:
<ul class="hlist">
<li><code><a title="eyecite.models.Token.from_match" href="#eyecite.models.Token.from_match">from_match</a></code></li>
<li><code><a title="eyecite.models.Token.merge" href="#eyecite.models.Token.merge">merge</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="eyecite.models.ReferenceCitation"><code class="flex name class">
<span>class <span class="ident">ReferenceCitation</span></span>
<span>(</span><span>token: <a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>, index: int, span_start: Optional[int] = None, span_end: Optional[int] = None, full_span_start: Optional[int] = None, full_span_end: Optional[int] = None, groups: dict = &lt;factory&gt;, metadata: Any = None, document: Optional[ForwardRef('<a title="eyecite.models.Document" href="#eyecite.models.Document">Document</a>')] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A reference citation is a citation that refers to
a full case citation by name and pincite alone.</p>
<p>Future versions hopefully with drop the pincite requirement</p>
<p>Examples:
Roe at 240</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, unsafe_hash=False, repr=False)
class ReferenceCitation(CitationBase):
    &#34;&#34;&#34;A reference citation is a citation that refers to
    a full case citation by name and pincite alone.

    Future versions hopefully with drop the pincite requirement

    Examples:
    Roe at 240
    &#34;&#34;&#34;

    @dataclass(eq=True, unsafe_hash=True)
    class Metadata(CitationBase.Metadata):
        &#34;&#34;&#34;Define fields on self.metadata.&#34;&#34;&#34;

        plaintiff: Optional[str] = None
        defendant: Optional[str] = None
        resolved_case_name_short: Optional[str] = None
        resolved_case_name: Optional[str] = None

    name_fields = [
        &#34;plaintiff&#34;,
        &#34;defendant&#34;,
        &#34;resolved_case_name_short&#34;,
        &#34;resolved_case_name&#34;,
    ]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eyecite.models.CitationBase" href="#eyecite.models.CitationBase">CitationBase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="eyecite.models.ReferenceCitation.name_fields"><code class="name">var <span class="ident">name_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="eyecite.models.CitationBase" href="#eyecite.models.CitationBase">CitationBase</a></b></code>:
<ul class="hlist">
<li><code><a title="eyecite.models.CitationBase.Metadata" href="#eyecite.models.CitationBase.Metadata">Metadata</a></code></li>
<li><code><a title="eyecite.models.CitationBase.corrected_citation" href="#eyecite.models.CitationBase.corrected_citation">corrected_citation</a></code></li>
<li><code><a title="eyecite.models.CitationBase.corrected_citation_full" href="#eyecite.models.CitationBase.corrected_citation_full">corrected_citation_full</a></code></li>
<li><code><a title="eyecite.models.CitationBase.dump" href="#eyecite.models.CitationBase.dump">dump</a></code></li>
<li><code><a title="eyecite.models.CitationBase.full_span" href="#eyecite.models.CitationBase.full_span">full_span</a></code></li>
<li><code><a title="eyecite.models.CitationBase.matched_text" href="#eyecite.models.CitationBase.matched_text">matched_text</a></code></li>
<li><code><a title="eyecite.models.CitationBase.span" href="#eyecite.models.CitationBase.span">span</a></code></li>
<li><code><a title="eyecite.models.CitationBase.span_with_pincite" href="#eyecite.models.CitationBase.span_with_pincite">span_with_pincite</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="eyecite.models.Reporter"><code class="flex name class">
<span>class <span class="ident">Reporter</span></span>
<span>(</span><span>short_name: str, name: str, cite_type: str, source: str, is_scotus: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for top-level reporters in <code>reporters_db</code>, like "S.W."</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=True, frozen=True)
class Reporter:
    &#34;&#34;&#34;Class for top-level reporters in `reporters_db`, like &#34;S.W.&#34; &#34;&#34;&#34;

    short_name: str
    name: str
    cite_type: str
    source: str  # one of &#34;reporters&#34;, &#34;laws&#34;, &#34;journals&#34;
    is_scotus: bool = False

    def __post_init__(self):
        if (
            self.cite_type == &#34;federal&#34; and &#34;supreme&#34; in self.name.lower()
        ) or &#34;scotus&#34; in self.cite_type.lower():
            # use setattr because this class is frozen
            object.__setattr__(self, &#34;is_scotus&#34;, True)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="eyecite.models.Reporter.cite_type"><code class="name">var <span class="ident">cite_type</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.Reporter.is_scotus"><code class="name">var <span class="ident">is_scotus</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.Reporter.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.Reporter.short_name"><code class="name">var <span class="ident">short_name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.Reporter.source"><code class="name">var <span class="ident">source</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="eyecite.models.Resource"><code class="flex name class">
<span>class <span class="ident">Resource</span></span>
<span>(</span><span>citation: <a title="eyecite.models.FullCitation" href="#eyecite.models.FullCitation">FullCitation</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Thin resource class representing an object to which a citation can be
resolved. See <code><a title="eyecite.resolve" href="resolve.html">eyecite.resolve</a></code> for more details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class Resource(ResourceType):
    &#34;&#34;&#34;Thin resource class representing an object to which a citation can be
    resolved. See `eyecite.resolve` for more details.&#34;&#34;&#34;

    citation: FullCitation

    def __hash__(self):
        &#34;&#34;&#34;Resources are the same if their citations are semantically
        equivalent, as defined by their hash function.

        Note: Resources composed of citations with missing page numbers are
        NOT considered the same, even if their other attributes are identical.
        This is to avoid potential false positives.
        &#34;&#34;&#34;
        return hash(
            hash_sha256(
                {
                    &#34;citation&#34;: hash(self.citation),
                    &#34;class&#34;: type(self).__name__,
                }
            )
        )

    def __eq__(self, other):
        return self.__hash__() == other.__hash__()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.Hashable</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="eyecite.models.Resource.citation"><code class="name">var <span class="ident">citation</span> : <a title="eyecite.models.FullCitation" href="#eyecite.models.FullCitation">FullCitation</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="eyecite.models.ResourceCitation"><code class="flex name class">
<span>class <span class="ident">ResourceCitation</span></span>
<span>(</span><span>token: <a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>, index: int, span_start: Optional[int] = None, span_end: Optional[int] = None, full_span_start: Optional[int] = None, full_span_end: Optional[int] = None, groups: dict = &lt;factory&gt;, metadata: Any = None, document: Optional[ForwardRef('<a title="eyecite.models.Document" href="#eyecite.models.Document">Document</a>')] = None, exact_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, variation_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, all_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, edition_guess: Optional[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = None, year: Optional[int] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for a case, law, or journal citation. Could be short or
long.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, unsafe_hash=False, repr=False)
class ResourceCitation(CitationBase):
    &#34;&#34;&#34;Base class for a case, law, or journal citation. Could be short or
    long.&#34;&#34;&#34;

    # Editions that might match this reporter string
    exact_editions: Sequence[Edition] = field(default_factory=tuple)
    variation_editions: Sequence[Edition] = field(default_factory=tuple)
    all_editions: Sequence[Edition] = field(default_factory=tuple)
    edition_guess: Optional[Edition] = None

    # year extracted from metadata[&#34;year&#34;] and converted to int,
    # if in a valid range
    year: Optional[int] = None

    def __post_init__(self):
        &#34;&#34;&#34;Make iterables into tuples to make sure we&#39;re hashable.&#34;&#34;&#34;
        self.exact_editions = tuple(self.exact_editions)
        self.variation_editions = tuple(self.variation_editions)
        self.all_editions = tuple(self.exact_editions) + tuple(
            self.variation_editions
        )
        super().__post_init__()

    def __hash__(self) -&gt; int:
        &#34;&#34;&#34;ResourceCitation objects are hashed in the same way as their
        parent class (CitationBase) objects, except that we also take into
        consideration the all_editions field.
        &#34;&#34;&#34;
        return hash(
            hash_sha256(
                {
                    **dict(self.groups.items()),
                    **{
                        &#34;all_editions&#34;: sorted(
                            [asdict(e) for e in self.all_editions],
                            key=lambda d: d[&#34;short_name&#34;],  # type: ignore
                        ),
                        &#34;class&#34;: type(self).__name__,
                    },
                }
            )
        )

    @dataclass(eq=True, unsafe_hash=True)
    class Metadata(CitationBase.Metadata):
        &#34;&#34;&#34;Define fields on self.metadata.&#34;&#34;&#34;

        year: Optional[str] = None

    def add_metadata(self, document: &#34;Document&#34;):
        &#34;&#34;&#34;Extract metadata from text before and after citation.&#34;&#34;&#34;
        self.guess_edition()

    def dump(self) -&gt; dict:
        &#34;&#34;&#34;Return citation data for printing by dump_citations.&#34;&#34;&#34;
        return {
            **super().dump(),
            &#34;year&#34;: self.year,
        }

    def corrected_reporter(self):
        &#34;&#34;&#34;Get official reporter string from edition_guess, if possible.&#34;&#34;&#34;
        return (
            self.edition_guess.short_name
            if self.edition_guess
            else self.groups[&#34;reporter&#34;]
        )

    def corrected_citation(self):
        &#34;&#34;&#34;Return citation with corrected reporter and standardized page&#34;&#34;&#34;
        corrected = self.matched_text()
        if self.edition_guess:
            corrected = corrected.replace(
                self.groups.get(&#34;reporter&#34;), self.edition_guess.short_name
            )

        corrected_page = self.corrected_page()
        if corrected_page and corrected_page != self.groups[&#34;page&#34;]:
            corrected = corrected.replace(self.groups[&#34;page&#34;], corrected_page)

        return corrected

    def corrected_page(self):
        &#34;&#34;&#34;Can we standardize a page value?&#34;&#34;&#34;
        page = self.groups.get(&#34;page&#34;)
        if page is None:
            return

        standard_reporter = &#34;&#34;
        if reporter := self.groups.get(&#34;reporter&#34;):
            if self.edition_guess:
                standard_reporter = self.edition_guess.short_name
            if {
                reporter,
                standard_reporter,
            } &amp; REPORTERS_THAT_NEED_PAGE_CORRECTION:
                return page.replace(&#34;[U]&#34;, &#34;(U)&#34;).replace(&#34;[A]&#34;, &#34;(A)&#34;)

        return page

    def guess_edition(self):
        &#34;&#34;&#34;Set edition_guess.&#34;&#34;&#34;
        # Use exact matches if possible, otherwise try variations
        editions = self.exact_editions or self.variation_editions
        if not editions:
            return

        # Attempt resolution by date
        if len(editions) &gt; 1 and self.year:
            editions = [e for e in editions if e.includes_year(self.year)]

        if len(editions) == 1:
            self.edition_guess = editions[0]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eyecite.models.CitationBase" href="#eyecite.models.CitationBase">CitationBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="eyecite.models.CaseCitation" href="#eyecite.models.CaseCitation">CaseCitation</a></li>
<li><a title="eyecite.models.FullCitation" href="#eyecite.models.FullCitation">FullCitation</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="eyecite.models.ResourceCitation.all_editions"><code class="name">var <span class="ident">all_editions</span> : Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.ResourceCitation.edition_guess"><code class="name">var <span class="ident">edition_guess</span> : Optional[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.ResourceCitation.exact_editions"><code class="name">var <span class="ident">exact_editions</span> : Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.ResourceCitation.variation_editions"><code class="name">var <span class="ident">variation_editions</span> : Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.ResourceCitation.year"><code class="name">var <span class="ident">year</span> : Optional[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="eyecite.models.ResourceCitation.add_metadata"><code class="name flex">
<span>def <span class="ident">add_metadata</span></span>(<span>self, document: <a title="eyecite.models.Document" href="#eyecite.models.Document">Document</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract metadata from text before and after citation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_metadata(self, document: &#34;Document&#34;):
    &#34;&#34;&#34;Extract metadata from text before and after citation.&#34;&#34;&#34;
    self.guess_edition()</code></pre>
</details>
</dd>
<dt id="eyecite.models.ResourceCitation.corrected_citation"><code class="name flex">
<span>def <span class="ident">corrected_citation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return citation with corrected reporter and standardized page</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corrected_citation(self):
    &#34;&#34;&#34;Return citation with corrected reporter and standardized page&#34;&#34;&#34;
    corrected = self.matched_text()
    if self.edition_guess:
        corrected = corrected.replace(
            self.groups.get(&#34;reporter&#34;), self.edition_guess.short_name
        )

    corrected_page = self.corrected_page()
    if corrected_page and corrected_page != self.groups[&#34;page&#34;]:
        corrected = corrected.replace(self.groups[&#34;page&#34;], corrected_page)

    return corrected</code></pre>
</details>
</dd>
<dt id="eyecite.models.ResourceCitation.corrected_page"><code class="name flex">
<span>def <span class="ident">corrected_page</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Can we standardize a page value?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corrected_page(self):
    &#34;&#34;&#34;Can we standardize a page value?&#34;&#34;&#34;
    page = self.groups.get(&#34;page&#34;)
    if page is None:
        return

    standard_reporter = &#34;&#34;
    if reporter := self.groups.get(&#34;reporter&#34;):
        if self.edition_guess:
            standard_reporter = self.edition_guess.short_name
        if {
            reporter,
            standard_reporter,
        } &amp; REPORTERS_THAT_NEED_PAGE_CORRECTION:
            return page.replace(&#34;[U]&#34;, &#34;(U)&#34;).replace(&#34;[A]&#34;, &#34;(A)&#34;)

    return page</code></pre>
</details>
</dd>
<dt id="eyecite.models.ResourceCitation.corrected_reporter"><code class="name flex">
<span>def <span class="ident">corrected_reporter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get official reporter string from edition_guess, if possible.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corrected_reporter(self):
    &#34;&#34;&#34;Get official reporter string from edition_guess, if possible.&#34;&#34;&#34;
    return (
        self.edition_guess.short_name
        if self.edition_guess
        else self.groups[&#34;reporter&#34;]
    )</code></pre>
</details>
</dd>
<dt id="eyecite.models.ResourceCitation.guess_edition"><code class="name flex">
<span>def <span class="ident">guess_edition</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set edition_guess.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def guess_edition(self):
    &#34;&#34;&#34;Set edition_guess.&#34;&#34;&#34;
    # Use exact matches if possible, otherwise try variations
    editions = self.exact_editions or self.variation_editions
    if not editions:
        return

    # Attempt resolution by date
    if len(editions) &gt; 1 and self.year:
        editions = [e for e in editions if e.includes_year(self.year)]

    if len(editions) == 1:
        self.edition_guess = editions[0]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="eyecite.models.CitationBase" href="#eyecite.models.CitationBase">CitationBase</a></b></code>:
<ul class="hlist">
<li><code><a title="eyecite.models.CitationBase.Metadata" href="#eyecite.models.CitationBase.Metadata">Metadata</a></code></li>
<li><code><a title="eyecite.models.CitationBase.corrected_citation_full" href="#eyecite.models.CitationBase.corrected_citation_full">corrected_citation_full</a></code></li>
<li><code><a title="eyecite.models.CitationBase.dump" href="#eyecite.models.CitationBase.dump">dump</a></code></li>
<li><code><a title="eyecite.models.CitationBase.full_span" href="#eyecite.models.CitationBase.full_span">full_span</a></code></li>
<li><code><a title="eyecite.models.CitationBase.matched_text" href="#eyecite.models.CitationBase.matched_text">matched_text</a></code></li>
<li><code><a title="eyecite.models.CitationBase.span" href="#eyecite.models.CitationBase.span">span</a></code></li>
<li><code><a title="eyecite.models.CitationBase.span_with_pincite" href="#eyecite.models.CitationBase.span_with_pincite">span_with_pincite</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="eyecite.models.SectionToken"><code class="flex name class">
<span>class <span class="ident">SectionToken</span></span>
<span>(</span><span>data: str, start: int, end: int, groups: dict = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Word containing a section symbol.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=True, unsafe_hash=True)
class SectionToken(Token):
    &#34;&#34;&#34;Word containing a section symbol.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a></li>
<li>collections.UserString</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a></b></code>:
<ul class="hlist">
<li><code><a title="eyecite.models.Token.from_match" href="#eyecite.models.Token.from_match">from_match</a></code></li>
<li><code><a title="eyecite.models.Token.merge" href="#eyecite.models.Token.merge">merge</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="eyecite.models.ShortCaseCitation"><code class="flex name class">
<span>class <span class="ident">ShortCaseCitation</span></span>
<span>(</span><span>token: <a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>, index: int, span_start: Optional[int] = None, span_end: Optional[int] = None, full_span_start: Optional[int] = None, full_span_end: Optional[int] = None, groups: dict = &lt;factory&gt;, metadata: Any = None, document: Optional[ForwardRef('<a title="eyecite.models.Document" href="#eyecite.models.Document">Document</a>')] = None, exact_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, variation_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, all_editions: Sequence[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = &lt;factory&gt;, edition_guess: Optional[<a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a>] = None, year: Optional[int] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience class which represents a short form citation, i.e., the kind
of citation made after a full citation has already appeared. This kind of
citation lacks a full case name and usually has a different page number
than the canonical citation.</p>
<p>Examples:</p>
<pre><code>Adarand, 515 U.S., at 241
Adarand, 515 U.S. at 241
515 U.S., at 241
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, unsafe_hash=False, repr=False)
class ShortCaseCitation(CaseCitation):
    &#34;&#34;&#34;Convenience class which represents a short form citation, i.e., the kind
    of citation made after a full citation has already appeared. This kind of
    citation lacks a full case name and usually has a different page number
    than the canonical citation.

    Examples:
    ```
    Adarand, 515 U.S., at 241
    Adarand, 515 U.S. at 241
    515 U.S., at 241
    ```
    &#34;&#34;&#34;

    @dataclass(eq=True, unsafe_hash=True)
    class Metadata(CaseCitation.Metadata):
        &#34;&#34;&#34;Define fields on self.metadata.&#34;&#34;&#34;

        antecedent_guess: Optional[str] = None

    def corrected_citation_full(self):
        &#34;&#34;&#34;Return formatted version of extracted cite.&#34;&#34;&#34;
        parts = []
        if self.metadata.antecedent_guess:
            parts.append(f&#34;{self.metadata.antecedent_guess}, &#34;)
        parts.append(self.corrected_citation())
        return &#34;&#34;.join(parts)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eyecite.models.CaseCitation" href="#eyecite.models.CaseCitation">CaseCitation</a></li>
<li><a title="eyecite.models.ResourceCitation" href="#eyecite.models.ResourceCitation">ResourceCitation</a></li>
<li><a title="eyecite.models.CitationBase" href="#eyecite.models.CitationBase">CitationBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="eyecite.models.ShortCaseCitation.corrected_citation_full"><code class="name flex">
<span>def <span class="ident">corrected_citation_full</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return formatted version of extracted cite.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corrected_citation_full(self):
    &#34;&#34;&#34;Return formatted version of extracted cite.&#34;&#34;&#34;
    parts = []
    if self.metadata.antecedent_guess:
        parts.append(f&#34;{self.metadata.antecedent_guess}, &#34;)
    parts.append(self.corrected_citation())
    return &#34;&#34;.join(parts)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="eyecite.models.CaseCitation" href="#eyecite.models.CaseCitation">CaseCitation</a></b></code>:
<ul class="hlist">
<li><code><a title="eyecite.models.CaseCitation.Metadata" href="#eyecite.models.CitationBase.Metadata">Metadata</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.add_metadata" href="#eyecite.models.ResourceCitation.add_metadata">add_metadata</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.corrected_citation" href="#eyecite.models.ResourceCitation.corrected_citation">corrected_citation</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.corrected_page" href="#eyecite.models.ResourceCitation.corrected_page">corrected_page</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.corrected_reporter" href="#eyecite.models.ResourceCitation.corrected_reporter">corrected_reporter</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.dump" href="#eyecite.models.CitationBase.dump">dump</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.full_span" href="#eyecite.models.CitationBase.full_span">full_span</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.guess_court" href="#eyecite.models.CaseCitation.guess_court">guess_court</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.guess_edition" href="#eyecite.models.ResourceCitation.guess_edition">guess_edition</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.matched_text" href="#eyecite.models.CitationBase.matched_text">matched_text</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.span" href="#eyecite.models.CitationBase.span">span</a></code></li>
<li><code><a title="eyecite.models.CaseCitation.span_with_pincite" href="#eyecite.models.CitationBase.span_with_pincite">span_with_pincite</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="eyecite.models.StopWordToken"><code class="flex name class">
<span>class <span class="ident">StopWordToken</span></span>
<span>(</span><span>data: str, start: int, end: int, groups: dict = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Word matching one of the STOP_TOKENS.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=True, unsafe_hash=True)
class StopWordToken(Token):
    &#34;&#34;&#34;Word matching one of the STOP_TOKENS.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a></li>
<li>collections.UserString</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a></b></code>:
<ul class="hlist">
<li><code><a title="eyecite.models.Token.from_match" href="#eyecite.models.Token.from_match">from_match</a></code></li>
<li><code><a title="eyecite.models.Token.merge" href="#eyecite.models.Token.merge">merge</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="eyecite.models.SupraCitation"><code class="flex name class">
<span>class <span class="ident">SupraCitation</span></span>
<span>(</span><span>token: <a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>, index: int, span_start: Optional[int] = None, span_end: Optional[int] = None, full_span_start: Optional[int] = None, full_span_end: Optional[int] = None, groups: dict = &lt;factory&gt;, metadata: Any = None, document: Optional[ForwardRef('<a title="eyecite.models.Document" href="#eyecite.models.Document">Document</a>')] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience class which represents a 'supra' citation, i.e., a citation
to something that is above in the document. Like a short form citation,
this kind of citation lacks a full case name and usually has a different
page number than the canonical citation.</p>
<p>Examples:</p>
<pre><code>Adarand, supra, at 240
Adarand, 515 supra, at 240
Adarand, supra, somethingelse
Adarand, supra. somethingelse
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, unsafe_hash=False, repr=False)
class SupraCitation(CitationBase):
    &#34;&#34;&#34;Convenience class which represents a &#39;supra&#39; citation, i.e., a citation
    to something that is above in the document. Like a short form citation,
    this kind of citation lacks a full case name and usually has a different
    page number than the canonical citation.


    Examples:
    ```
    Adarand, supra, at 240
    Adarand, 515 supra, at 240
    Adarand, supra, somethingelse
    Adarand, supra. somethingelse
    ```
    &#34;&#34;&#34;

    @dataclass(eq=True, unsafe_hash=True)
    class Metadata(CitationBase.Metadata):
        &#34;&#34;&#34;Define fields on self.metadata.&#34;&#34;&#34;

        antecedent_guess: Optional[str] = None
        volume: Optional[str] = None

    def formatted(self):
        &#34;&#34;&#34;Return formatted version of extracted cite.&#34;&#34;&#34;
        parts = []
        m = self.metadata
        if m.antecedent_guess:
            parts.append(f&#34;{m.antecedent_guess}, &#34;)
        if m.volume:
            parts.append(f&#34;{m.volume} &#34;)
        parts.append(&#34;supra&#34;)
        if m.pin_cite:
            parts.append(f&#34;, {m.pin_cite}&#34;)
        return &#34;&#34;.join(parts)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eyecite.models.CitationBase" href="#eyecite.models.CitationBase">CitationBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="eyecite.models.SupraCitation.formatted"><code class="name flex">
<span>def <span class="ident">formatted</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return formatted version of extracted cite.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formatted(self):
    &#34;&#34;&#34;Return formatted version of extracted cite.&#34;&#34;&#34;
    parts = []
    m = self.metadata
    if m.antecedent_guess:
        parts.append(f&#34;{m.antecedent_guess}, &#34;)
    if m.volume:
        parts.append(f&#34;{m.volume} &#34;)
    parts.append(&#34;supra&#34;)
    if m.pin_cite:
        parts.append(f&#34;, {m.pin_cite}&#34;)
    return &#34;&#34;.join(parts)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="eyecite.models.CitationBase" href="#eyecite.models.CitationBase">CitationBase</a></b></code>:
<ul class="hlist">
<li><code><a title="eyecite.models.CitationBase.Metadata" href="#eyecite.models.CitationBase.Metadata">Metadata</a></code></li>
<li><code><a title="eyecite.models.CitationBase.corrected_citation" href="#eyecite.models.CitationBase.corrected_citation">corrected_citation</a></code></li>
<li><code><a title="eyecite.models.CitationBase.corrected_citation_full" href="#eyecite.models.CitationBase.corrected_citation_full">corrected_citation_full</a></code></li>
<li><code><a title="eyecite.models.CitationBase.dump" href="#eyecite.models.CitationBase.dump">dump</a></code></li>
<li><code><a title="eyecite.models.CitationBase.full_span" href="#eyecite.models.CitationBase.full_span">full_span</a></code></li>
<li><code><a title="eyecite.models.CitationBase.matched_text" href="#eyecite.models.CitationBase.matched_text">matched_text</a></code></li>
<li><code><a title="eyecite.models.CitationBase.span" href="#eyecite.models.CitationBase.span">span</a></code></li>
<li><code><a title="eyecite.models.CitationBase.span_with_pincite" href="#eyecite.models.CitationBase.span_with_pincite">span_with_pincite</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="eyecite.models.SupraToken"><code class="flex name class">
<span>class <span class="ident">SupraToken</span></span>
<span>(</span><span>data: str, start: int, end: int, groups: dict = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Word matching "supra" with or without punctuation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=True, unsafe_hash=True)
class SupraToken(Token):
    &#34;&#34;&#34;Word matching &#34;supra&#34; with or without punctuation.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a></li>
<li>collections.UserString</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a></b></code>:
<ul class="hlist">
<li><code><a title="eyecite.models.Token.from_match" href="#eyecite.models.Token.from_match">from_match</a></code></li>
<li><code><a title="eyecite.models.Token.merge" href="#eyecite.models.Token.merge">merge</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="eyecite.models.Token"><code class="flex name class">
<span>class <span class="ident">Token</span></span>
<span>(</span><span>data: str, start: int, end: int, groups: dict = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for special tokens. For performance, this isn't used
for generic words.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=True, unsafe_hash=True)
class Token(UserString):
    &#34;&#34;&#34;Base class for special tokens. For performance, this isn&#39;t used
    for generic words.&#34;&#34;&#34;

    data: str
    start: int
    end: int
    groups: dict = field(default_factory=dict, compare=False)

    @classmethod
    def from_match(cls, m, extra, offset=0) -&gt; &#34;Token&#34;:
        &#34;&#34;&#34;Return a token object based on a regular expression match.
        This gets called by TokenExtractor. By default, just use the
        entire matched string.&#34;&#34;&#34;
        start, end = m.span(1)
        # ignore &#34;too many arguments&#34; type error -- this is called
        # by subclasses with additional attributes
        return cls(  # type: ignore[call-arg]
            m[1], start + offset, end + offset, groups=m.groupdict(), **extra
        )

    def merge(self, other: &#34;Token&#34;) -&gt; Optional[&#34;Token&#34;]:
        &#34;&#34;&#34;Merge two tokens, by returning self if other is identical to
        self.&#34;&#34;&#34;
        if (
            self.start == other.start
            and self.end == other.end
            and type(self) is type(other)
            and self.groups == other.groups
        ):
            return self
        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.UserString</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="eyecite.models.CaseReferenceToken" href="#eyecite.models.CaseReferenceToken">CaseReferenceToken</a></li>
<li><a title="eyecite.models.CitationToken" href="#eyecite.models.CitationToken">CitationToken</a></li>
<li><a title="eyecite.models.IdToken" href="#eyecite.models.IdToken">IdToken</a></li>
<li><a title="eyecite.models.ParagraphToken" href="#eyecite.models.ParagraphToken">ParagraphToken</a></li>
<li><a title="eyecite.models.PlaceholderCitationToken" href="#eyecite.models.PlaceholderCitationToken">PlaceholderCitationToken</a></li>
<li><a title="eyecite.models.SectionToken" href="#eyecite.models.SectionToken">SectionToken</a></li>
<li><a title="eyecite.models.StopWordToken" href="#eyecite.models.StopWordToken">StopWordToken</a></li>
<li><a title="eyecite.models.SupraToken" href="#eyecite.models.SupraToken">SupraToken</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="eyecite.models.Token.data"><code class="name">var <span class="ident">data</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.Token.end"><code class="name">var <span class="ident">end</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.Token.groups"><code class="name">var <span class="ident">groups</span> : dict</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.Token.start"><code class="name">var <span class="ident">start</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="eyecite.models.Token.from_match"><code class="name flex">
<span>def <span class="ident">from_match</span></span>(<span>m, extra, offset=0) ‑> <a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return a token object based on a regular expression match.
This gets called by TokenExtractor. By default, just use the
entire matched string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_match(cls, m, extra, offset=0) -&gt; &#34;Token&#34;:
    &#34;&#34;&#34;Return a token object based on a regular expression match.
    This gets called by TokenExtractor. By default, just use the
    entire matched string.&#34;&#34;&#34;
    start, end = m.span(1)
    # ignore &#34;too many arguments&#34; type error -- this is called
    # by subclasses with additional attributes
    return cls(  # type: ignore[call-arg]
        m[1], start + offset, end + offset, groups=m.groupdict(), **extra
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="eyecite.models.Token.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self, other: <a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>) ‑> Optional[<a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Merge two tokens, by returning self if other is identical to
self.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge(self, other: &#34;Token&#34;) -&gt; Optional[&#34;Token&#34;]:
    &#34;&#34;&#34;Merge two tokens, by returning self if other is identical to
    self.&#34;&#34;&#34;
    if (
        self.start == other.start
        and self.end == other.end
        and type(self) is type(other)
        and self.groups == other.groups
    ):
        return self
    return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="eyecite.models.TokenExtractor"><code class="flex name class">
<span>class <span class="ident">TokenExtractor</span></span>
<span>(</span><span>regex: str, constructor: Callable[..., <a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>], extra: Dict = &lt;factory&gt;, flags: int = 0, strings: List = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for extracting all matches from a given string for the given
regex, and then for returning Token objects for all matches.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class TokenExtractor:
    &#34;&#34;&#34;Class for extracting all matches from a given string for the given
    regex, and then for returning Token objects for all matches.&#34;&#34;&#34;

    regex: str
    # constructor should be Callable[[re.Match, dict, int], Token]
    # but this issue makes it inconvenient to specify the input types:
    # https://github.com/python/mypy/issues/5485
    constructor: Callable[..., Token]
    extra: Dict = field(default_factory=dict)
    flags: int = 0
    strings: List = field(default_factory=list)

    def get_matches(self, text):
        &#34;&#34;&#34;Return match objects for all matches in text.&#34;&#34;&#34;
        return self.compiled_regex.finditer(text)

    def get_token(self, m, offset=0) -&gt; Token:
        &#34;&#34;&#34;For a given match object, return a Token.&#34;&#34;&#34;
        return self.constructor(m, self.extra, offset)

    def __hash__(self):
        &#34;&#34;&#34;This needs to be hashable so we can remove redundant
        extractors returned by the pyahocorasick filter.&#34;&#34;&#34;
        return hash(repr(self))

    @property
    def compiled_regex(self):
        &#34;&#34;&#34;Cache compiled regex as a property.&#34;&#34;&#34;
        if not hasattr(self, &#34;_compiled_regex&#34;):
            self._compiled_regex = re.compile(self.regex, flags=self.flags)
        return self._compiled_regex</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="eyecite.models.TokenExtractor.constructor"><code class="name">var <span class="ident">constructor</span> : Callable[..., <a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.TokenExtractor.extra"><code class="name">var <span class="ident">extra</span> : Dict</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.TokenExtractor.flags"><code class="name">var <span class="ident">flags</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.TokenExtractor.regex"><code class="name">var <span class="ident">regex</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eyecite.models.TokenExtractor.strings"><code class="name">var <span class="ident">strings</span> : List</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="eyecite.models.TokenExtractor.compiled_regex"><code class="name">var <span class="ident">compiled_regex</span></code></dt>
<dd>
<div class="desc"><p>Cache compiled regex as a property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def compiled_regex(self):
    &#34;&#34;&#34;Cache compiled regex as a property.&#34;&#34;&#34;
    if not hasattr(self, &#34;_compiled_regex&#34;):
        self._compiled_regex = re.compile(self.regex, flags=self.flags)
    return self._compiled_regex</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="eyecite.models.TokenExtractor.get_matches"><code class="name flex">
<span>def <span class="ident">get_matches</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>Return match objects for all matches in text.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_matches(self, text):
    &#34;&#34;&#34;Return match objects for all matches in text.&#34;&#34;&#34;
    return self.compiled_regex.finditer(text)</code></pre>
</details>
</dd>
<dt id="eyecite.models.TokenExtractor.get_token"><code class="name flex">
<span>def <span class="ident">get_token</span></span>(<span>self, m, offset=0) ‑> <a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a></span>
</code></dt>
<dd>
<div class="desc"><p>For a given match object, return a Token.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_token(self, m, offset=0) -&gt; Token:
    &#34;&#34;&#34;For a given match object, return a Token.&#34;&#34;&#34;
    return self.constructor(m, self.extra, offset)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="eyecite.models.UnknownCitation"><code class="flex name class">
<span>class <span class="ident">UnknownCitation</span></span>
<span>(</span><span>token: <a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a>, index: int, span_start: Optional[int] = None, span_end: Optional[int] = None, full_span_start: Optional[int] = None, full_span_end: Optional[int] = None, groups: dict = &lt;factory&gt;, metadata: Any = None, document: Optional[ForwardRef('<a title="eyecite.models.Document" href="#eyecite.models.Document">Document</a>')] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience class which represents an unknown citation. A recognized
citation should theoretically be parsed as a CaseCitation, FullLawCitation,
or a FullJournalCitation. If it's something else, this class serves as
a naive catch-all.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(eq=False, unsafe_hash=False, repr=False)
class UnknownCitation(CitationBase):
    &#34;&#34;&#34;Convenience class which represents an unknown citation. A recognized
    citation should theoretically be parsed as a CaseCitation, FullLawCitation,
    or a FullJournalCitation. If it&#39;s something else, this class serves as
    a naive catch-all.
    &#34;&#34;&#34;

    def __hash__(self) -&gt; int:
        &#34;&#34;&#34;UnknownCitation objects are always considered unique for safety.&#34;&#34;&#34;
        return id(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eyecite.models.CitationBase" href="#eyecite.models.CitationBase">CitationBase</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="eyecite.models.CitationBase" href="#eyecite.models.CitationBase">CitationBase</a></b></code>:
<ul class="hlist">
<li><code><a title="eyecite.models.CitationBase.Metadata" href="#eyecite.models.CitationBase.Metadata">Metadata</a></code></li>
<li><code><a title="eyecite.models.CitationBase.corrected_citation" href="#eyecite.models.CitationBase.corrected_citation">corrected_citation</a></code></li>
<li><code><a title="eyecite.models.CitationBase.corrected_citation_full" href="#eyecite.models.CitationBase.corrected_citation_full">corrected_citation_full</a></code></li>
<li><code><a title="eyecite.models.CitationBase.dump" href="#eyecite.models.CitationBase.dump">dump</a></code></li>
<li><code><a title="eyecite.models.CitationBase.full_span" href="#eyecite.models.CitationBase.full_span">full_span</a></code></li>
<li><code><a title="eyecite.models.CitationBase.matched_text" href="#eyecite.models.CitationBase.matched_text">matched_text</a></code></li>
<li><code><a title="eyecite.models.CitationBase.span" href="#eyecite.models.CitationBase.span">span</a></code></li>
<li><code><a title="eyecite.models.CitationBase.span_with_pincite" href="#eyecite.models.CitationBase.span_with_pincite">span_with_pincite</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="eyecite" href="index.html">eyecite</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="eyecite.models.CaseCitation" href="#eyecite.models.CaseCitation">CaseCitation</a></code></h4>
<ul class="">
<li><code><a title="eyecite.models.CaseCitation.guess_court" href="#eyecite.models.CaseCitation.guess_court">guess_court</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eyecite.models.CaseReferenceToken" href="#eyecite.models.CaseReferenceToken">CaseReferenceToken</a></code></h4>
</li>
<li>
<h4><code><a title="eyecite.models.CitationBase" href="#eyecite.models.CitationBase">CitationBase</a></code></h4>
<ul class="">
<li><code><a title="eyecite.models.CitationBase.Metadata" href="#eyecite.models.CitationBase.Metadata">Metadata</a></code></li>
<li><code><a title="eyecite.models.CitationBase.corrected_citation" href="#eyecite.models.CitationBase.corrected_citation">corrected_citation</a></code></li>
<li><code><a title="eyecite.models.CitationBase.corrected_citation_full" href="#eyecite.models.CitationBase.corrected_citation_full">corrected_citation_full</a></code></li>
<li><code><a title="eyecite.models.CitationBase.document" href="#eyecite.models.CitationBase.document">document</a></code></li>
<li><code><a title="eyecite.models.CitationBase.dump" href="#eyecite.models.CitationBase.dump">dump</a></code></li>
<li><code><a title="eyecite.models.CitationBase.full_span" href="#eyecite.models.CitationBase.full_span">full_span</a></code></li>
<li><code><a title="eyecite.models.CitationBase.full_span_end" href="#eyecite.models.CitationBase.full_span_end">full_span_end</a></code></li>
<li><code><a title="eyecite.models.CitationBase.full_span_start" href="#eyecite.models.CitationBase.full_span_start">full_span_start</a></code></li>
<li><code><a title="eyecite.models.CitationBase.groups" href="#eyecite.models.CitationBase.groups">groups</a></code></li>
<li><code><a title="eyecite.models.CitationBase.index" href="#eyecite.models.CitationBase.index">index</a></code></li>
<li><code><a title="eyecite.models.CitationBase.matched_text" href="#eyecite.models.CitationBase.matched_text">matched_text</a></code></li>
<li><code><a title="eyecite.models.CitationBase.metadata" href="#eyecite.models.CitationBase.metadata">metadata</a></code></li>
<li><code><a title="eyecite.models.CitationBase.span" href="#eyecite.models.CitationBase.span">span</a></code></li>
<li><code><a title="eyecite.models.CitationBase.span_end" href="#eyecite.models.CitationBase.span_end">span_end</a></code></li>
<li><code><a title="eyecite.models.CitationBase.span_start" href="#eyecite.models.CitationBase.span_start">span_start</a></code></li>
<li><code><a title="eyecite.models.CitationBase.span_with_pincite" href="#eyecite.models.CitationBase.span_with_pincite">span_with_pincite</a></code></li>
<li><code><a title="eyecite.models.CitationBase.token" href="#eyecite.models.CitationBase.token">token</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eyecite.models.CitationToken" href="#eyecite.models.CitationToken">CitationToken</a></code></h4>
<ul class="">
<li><code><a title="eyecite.models.CitationToken.exact_editions" href="#eyecite.models.CitationToken.exact_editions">exact_editions</a></code></li>
<li><code><a title="eyecite.models.CitationToken.merge" href="#eyecite.models.CitationToken.merge">merge</a></code></li>
<li><code><a title="eyecite.models.CitationToken.short" href="#eyecite.models.CitationToken.short">short</a></code></li>
<li><code><a title="eyecite.models.CitationToken.variation_editions" href="#eyecite.models.CitationToken.variation_editions">variation_editions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eyecite.models.Document" href="#eyecite.models.Document">Document</a></code></h4>
<ul class="">
<li><code><a title="eyecite.models.Document.citation_tokens" href="#eyecite.models.Document.citation_tokens">citation_tokens</a></code></li>
<li><code><a title="eyecite.models.Document.clean_steps" href="#eyecite.models.Document.clean_steps">clean_steps</a></code></li>
<li><code><a title="eyecite.models.Document.emphasis_tags" href="#eyecite.models.Document.emphasis_tags">emphasis_tags</a></code></li>
<li><code><a title="eyecite.models.Document.identify_emphasis_tags" href="#eyecite.models.Document.identify_emphasis_tags">identify_emphasis_tags</a></code></li>
<li><code><a title="eyecite.models.Document.markup_text" href="#eyecite.models.Document.markup_text">markup_text</a></code></li>
<li><code><a title="eyecite.models.Document.markup_to_plain" href="#eyecite.models.Document.markup_to_plain">markup_to_plain</a></code></li>
<li><code><a title="eyecite.models.Document.plain_text" href="#eyecite.models.Document.plain_text">plain_text</a></code></li>
<li><code><a title="eyecite.models.Document.plain_to_markup" href="#eyecite.models.Document.plain_to_markup">plain_to_markup</a></code></li>
<li><code><a title="eyecite.models.Document.source_text" href="#eyecite.models.Document.source_text">source_text</a></code></li>
<li><code><a title="eyecite.models.Document.tokenize" href="#eyecite.models.Document.tokenize">tokenize</a></code></li>
<li><code><a title="eyecite.models.Document.words" href="#eyecite.models.Document.words">words</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eyecite.models.Edition" href="#eyecite.models.Edition">Edition</a></code></h4>
<ul class="">
<li><code><a title="eyecite.models.Edition.end" href="#eyecite.models.Edition.end">end</a></code></li>
<li><code><a title="eyecite.models.Edition.includes_year" href="#eyecite.models.Edition.includes_year">includes_year</a></code></li>
<li><code><a title="eyecite.models.Edition.reporter" href="#eyecite.models.Edition.reporter">reporter</a></code></li>
<li><code><a title="eyecite.models.Edition.short_name" href="#eyecite.models.Edition.short_name">short_name</a></code></li>
<li><code><a title="eyecite.models.Edition.start" href="#eyecite.models.Edition.start">start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eyecite.models.FullCaseCitation" href="#eyecite.models.FullCaseCitation">FullCaseCitation</a></code></h4>
<ul class="">
<li><code><a title="eyecite.models.FullCaseCitation.corrected_citation_full" href="#eyecite.models.FullCaseCitation.corrected_citation_full">corrected_citation_full</a></code></li>
<li><code><a title="eyecite.models.FullCaseCitation.is_parallel_citation" href="#eyecite.models.FullCaseCitation.is_parallel_citation">is_parallel_citation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eyecite.models.FullCitation" href="#eyecite.models.FullCitation">FullCitation</a></code></h4>
</li>
<li>
<h4><code><a title="eyecite.models.FullJournalCitation" href="#eyecite.models.FullJournalCitation">FullJournalCitation</a></code></h4>
</li>
<li>
<h4><code><a title="eyecite.models.FullLawCitation" href="#eyecite.models.FullLawCitation">FullLawCitation</a></code></h4>
</li>
<li>
<h4><code><a title="eyecite.models.IdCitation" href="#eyecite.models.IdCitation">IdCitation</a></code></h4>
<ul class="">
<li><code><a title="eyecite.models.IdCitation.formatted" href="#eyecite.models.IdCitation.formatted">formatted</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eyecite.models.IdToken" href="#eyecite.models.IdToken">IdToken</a></code></h4>
</li>
<li>
<h4><code><a title="eyecite.models.ParagraphToken" href="#eyecite.models.ParagraphToken">ParagraphToken</a></code></h4>
</li>
<li>
<h4><code><a title="eyecite.models.PlaceholderCitationToken" href="#eyecite.models.PlaceholderCitationToken">PlaceholderCitationToken</a></code></h4>
</li>
<li>
<h4><code><a title="eyecite.models.ReferenceCitation" href="#eyecite.models.ReferenceCitation">ReferenceCitation</a></code></h4>
<ul class="">
<li><code><a title="eyecite.models.ReferenceCitation.name_fields" href="#eyecite.models.ReferenceCitation.name_fields">name_fields</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eyecite.models.Reporter" href="#eyecite.models.Reporter">Reporter</a></code></h4>
<ul class="">
<li><code><a title="eyecite.models.Reporter.cite_type" href="#eyecite.models.Reporter.cite_type">cite_type</a></code></li>
<li><code><a title="eyecite.models.Reporter.is_scotus" href="#eyecite.models.Reporter.is_scotus">is_scotus</a></code></li>
<li><code><a title="eyecite.models.Reporter.name" href="#eyecite.models.Reporter.name">name</a></code></li>
<li><code><a title="eyecite.models.Reporter.short_name" href="#eyecite.models.Reporter.short_name">short_name</a></code></li>
<li><code><a title="eyecite.models.Reporter.source" href="#eyecite.models.Reporter.source">source</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eyecite.models.Resource" href="#eyecite.models.Resource">Resource</a></code></h4>
<ul class="">
<li><code><a title="eyecite.models.Resource.citation" href="#eyecite.models.Resource.citation">citation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eyecite.models.ResourceCitation" href="#eyecite.models.ResourceCitation">ResourceCitation</a></code></h4>
<ul class="two-column">
<li><code><a title="eyecite.models.ResourceCitation.add_metadata" href="#eyecite.models.ResourceCitation.add_metadata">add_metadata</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.all_editions" href="#eyecite.models.ResourceCitation.all_editions">all_editions</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.corrected_citation" href="#eyecite.models.ResourceCitation.corrected_citation">corrected_citation</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.corrected_page" href="#eyecite.models.ResourceCitation.corrected_page">corrected_page</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.corrected_reporter" href="#eyecite.models.ResourceCitation.corrected_reporter">corrected_reporter</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.edition_guess" href="#eyecite.models.ResourceCitation.edition_guess">edition_guess</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.exact_editions" href="#eyecite.models.ResourceCitation.exact_editions">exact_editions</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.guess_edition" href="#eyecite.models.ResourceCitation.guess_edition">guess_edition</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.variation_editions" href="#eyecite.models.ResourceCitation.variation_editions">variation_editions</a></code></li>
<li><code><a title="eyecite.models.ResourceCitation.year" href="#eyecite.models.ResourceCitation.year">year</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eyecite.models.SectionToken" href="#eyecite.models.SectionToken">SectionToken</a></code></h4>
</li>
<li>
<h4><code><a title="eyecite.models.ShortCaseCitation" href="#eyecite.models.ShortCaseCitation">ShortCaseCitation</a></code></h4>
<ul class="">
<li><code><a title="eyecite.models.ShortCaseCitation.corrected_citation_full" href="#eyecite.models.ShortCaseCitation.corrected_citation_full">corrected_citation_full</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eyecite.models.StopWordToken" href="#eyecite.models.StopWordToken">StopWordToken</a></code></h4>
</li>
<li>
<h4><code><a title="eyecite.models.SupraCitation" href="#eyecite.models.SupraCitation">SupraCitation</a></code></h4>
<ul class="">
<li><code><a title="eyecite.models.SupraCitation.formatted" href="#eyecite.models.SupraCitation.formatted">formatted</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eyecite.models.SupraToken" href="#eyecite.models.SupraToken">SupraToken</a></code></h4>
</li>
<li>
<h4><code><a title="eyecite.models.Token" href="#eyecite.models.Token">Token</a></code></h4>
<ul class="two-column">
<li><code><a title="eyecite.models.Token.data" href="#eyecite.models.Token.data">data</a></code></li>
<li><code><a title="eyecite.models.Token.end" href="#eyecite.models.Token.end">end</a></code></li>
<li><code><a title="eyecite.models.Token.from_match" href="#eyecite.models.Token.from_match">from_match</a></code></li>
<li><code><a title="eyecite.models.Token.groups" href="#eyecite.models.Token.groups">groups</a></code></li>
<li><code><a title="eyecite.models.Token.merge" href="#eyecite.models.Token.merge">merge</a></code></li>
<li><code><a title="eyecite.models.Token.start" href="#eyecite.models.Token.start">start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eyecite.models.TokenExtractor" href="#eyecite.models.TokenExtractor">TokenExtractor</a></code></h4>
<ul class="two-column">
<li><code><a title="eyecite.models.TokenExtractor.compiled_regex" href="#eyecite.models.TokenExtractor.compiled_regex">compiled_regex</a></code></li>
<li><code><a title="eyecite.models.TokenExtractor.constructor" href="#eyecite.models.TokenExtractor.constructor">constructor</a></code></li>
<li><code><a title="eyecite.models.TokenExtractor.extra" href="#eyecite.models.TokenExtractor.extra">extra</a></code></li>
<li><code><a title="eyecite.models.TokenExtractor.flags" href="#eyecite.models.TokenExtractor.flags">flags</a></code></li>
<li><code><a title="eyecite.models.TokenExtractor.get_matches" href="#eyecite.models.TokenExtractor.get_matches">get_matches</a></code></li>
<li><code><a title="eyecite.models.TokenExtractor.get_token" href="#eyecite.models.TokenExtractor.get_token">get_token</a></code></li>
<li><code><a title="eyecite.models.TokenExtractor.regex" href="#eyecite.models.TokenExtractor.regex">regex</a></code></li>
<li><code><a title="eyecite.models.TokenExtractor.strings" href="#eyecite.models.TokenExtractor.strings">strings</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eyecite.models.UnknownCitation" href="#eyecite.models.UnknownCitation">UnknownCitation</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>